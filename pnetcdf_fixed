//
// generic include file for the PnetCDF C++ API
//

#include <exception>
#include <string>
#include <typeinfo>
#include <vector>
#include <set>
#include <map>

#include <pnetcdf.h>

extern int
ncmpi_insert_compound(int ncid, nc_type xtype, const char *name,
                   MPI_Offset offset, nc_type field_typeid);

/* Insert a named array into a compound type. */
extern int
ncmpi_insert_array_compound(int ncid, nc_type xtype, const char *name,
                         MPI_Offset offset, nc_type field_typeid,
                         int ndims, const int *dim_sizes);
extern int
ncmpi_insert_enum(int ncid, nc_type xtype, const char *name,
               const void *value);
extern int
ncmpi_def_compound(int ncid, MPI_Offset size, const char *name, nc_type *typeidp);

extern int
ncmpi_inq_enum(int ncid, nc_type xtype, char *name, nc_type *base_nc_typep,
            MPI_Offset *base_sizep, MPI_Offset *num_membersp);

/* Get information about an enum member: a name and value. Name size
 *  * will be <= NC_MAX_NAME. */
extern int
ncmpi_inq_enum_member(int ncid, nc_type xtype, int idx, char *name,
                   void *value);

extern int
ncmpi_inq_enum_ident(int ncid, nc_type xtype, long long value, char *identifier);

extern int
ncmpi_inq_compound_nfields(int ncid, nc_type xtype, MPI_Offset *nfieldsp);

extern int
ncmpi_inq_compound_name(int ncid, nc_type xtype, char *name);

/* Get the size of a compound type. */
extern int
ncmpi_inq_compound_size(int ncid, nc_type xtype, MPI_Offset *sizep);

/* Get the number of fields in this compound type. */
extern int
ncmpi_inq_compound_nfields(int ncid, nc_type xtype, MPI_Offset *nfieldsp);

/* Given the xtype and the fieldid, get all info about it. */
extern int
ncmpi_inq_compound_field(int ncid, nc_type xtype, int fieldid, char *name,
                      MPI_Offset *offsetp, nc_type *field_typeidp, int *ndimsp,
                      int *dim_sizesp);

/* Given the typeid and the fieldid, get the name. */
extern int
ncmpi_inq_compound_fieldname(int ncid, nc_type xtype, int fieldid,
                          char *name);
extern int
ncmpi_inq_compound(int ncid, nc_type xtype, char *name, MPI_Offset *sizep,
                MPI_Offset *nfieldsp);
/* Given the xtype and the name, get the fieldid. */
extern int
ncmpi_inq_compound_fieldindex(int ncid, nc_type xtype, const char *name,
                           int *fieldidp);

/* Given the xtype and fieldid, get the offset. */
extern int
ncmpi_inq_compound_fieldoffset(int ncid, nc_type xtype, int fieldid,
                            MPI_Offset *offsetp);

/* Given the xtype and the fieldid, get the type of that field. */
extern int
ncmpi_inq_compound_fieldtype(int ncid, nc_type xtype, int fieldid,
                          nc_type *field_typeidp);

/* Given the xtype and the fieldid, get the number of dimensions for
 *  * that field (scalars are 0). */
extern int
ncmpi_inq_compound_fieldndims(int ncid, nc_type xtype, int fieldid,
                           int *ndimsp);
extern int
ncmpi_inq_compound_fielddim_sizes(int ncid, nc_type xtype, int fieldid,
                               int *dim_sizes);

extern int
ncmpi_inq_unlimdims(int ncid, int *nunlimdimsp, int *unlimdimidsp);

extern int
ncmpi_inq_grpname_len(int ncid, MPI_Offset *lenp);

/* Given an ncid, find the ncid of its parent group. */
extern int
ncmpi_inq_grp_parent(int ncid, int *parent_ncid);

/* Given a name and parent ncid, find group ncid. */
extern int
ncmpi_inq_grp_ncid(int ncid, const char *grp_name, int *grp_ncid);
/* Given a full name and ncid, find group ncid. */
extern int
ncmpi_inq_grp_full_ncid(int ncid, const char *full_name, int *grp_ncid);

/* Get a list of ids for all the variables in a group. */
extern int
ncmpi_inq_varids(int ncid, int *nvars, int *varids);

/* Find all dimids for a location. This finds all dimensions in a
 *  * group, or any of its parents. */
extern int
ncmpi_inq_dimids(int ncid, int *ndims, int *dimids, int include_parents);

extern int
ncmpi_inq_type(int ncid, nc_type xtype, char *name, MPI_Offset *size);

/* Find all user-defined types for a location. This finds all
 *  * user-defined types in a group. */
extern int
ncmpi_inq_typeids(int ncid, int *ntypes, int *typeids);

/* Are two types equal? */
extern int
ncmpi_inq_type_equal(int ncid1, nc_type typeid1, int ncid2,
                  nc_type typeid2, int *equal);
/* Create a group. its ncid is returned in the new_ncid pointer. */
extern int
ncmpi_def_grp(int parent_ncid, const char *name, int *new_ncid);

/* Rename a group */
extern int
ncmpi_rename_grp(int grpid, const char *name);

extern int
ncmpi_inq_grps(int ncid, int *numgrps, int *ncids);

/* Given locid, find name of group. (Root group is named "/".) */
extern int
ncmpi_inq_grpname(int ncid, char *name);

/* Given ncid, find full name and len of full name. (Root group is
 *  * named "/", with length 1.) */
extern int
ncmpi_inq_grpname_full(int ncid, MPI_Offset *lenp, char *full_name);

extern int
ncmpi_def_enum(int ncid, nc_type base_typeid, const char *name,
            nc_type *typeidp);

extern int
ncmpi_def_vlen(int ncid, const char *name, nc_type base_typeid, nc_type *xtypep);

/* Find out about a vlen. */
extern int
ncmpi_inq_vlen(int ncid, nc_type xtype, char *name, MPI_Offset *datum_sizep,
            nc_type *base_nc_typep);

typedef struct {
    MPI_Offset len; /**< Length of VL data (in base type units) */
    void *p;    /**< Pointer to VL data */
} nc_vlen_t;

extern int
ncmpi_free_vlen(nc_vlen_t *vl);

extern int
ncmpi_free_vlens(MPI_Offset len, nc_vlen_t vlens[]);

/* Put or get one element in a vlen array. */
extern int
ncmpi_put_vlen_element(int ncid, int typeid1, void *vlen_element,
                    MPI_Offset len, const void *data);

extern int
ncmpi_get_vlen_element(int ncid, int typeid1, const void *vlen_element,
                    MPI_Offset *len, void *data);
extern int
ncmpi_def_opaque(int ncid, MPI_Offset size, const char *name, nc_type *xtypep);

/* Get information about an opaque type. */
extern int
ncmpi_inq_opaque(int ncid, nc_type xtype, char *name, MPI_Offset *sizep);

extern int
ncmpi_inq_user_type(int ncid, nc_type xtype, char *name, MPI_Offset *size,
                 nc_type *base_nc_typep, MPI_Offset *nfieldsp, int *classp);

extern int
ncmpi_def_var_chunking(int ncid, int varid, int storage, const MPI_Offset *chunksizesp);
extern int
ncmpi_inq_var_chunking(int ncid, int varid, int *storagep, MPI_Offset *chunksizesp);

extern int
ncmpi_def_var_endian(int ncid, int varid, int endian);

/* Learn about the endianness of a variable. */
extern int
ncmpi_inq_var_endian(int ncid, int varid, int *endianp);
extern int
ncmpi_set_chunk_cache(MPI_Offset size, MPI_Offset nelems, float preemption);

extern int
ncmpi_def_var_deflate(int ncid, int varid, int shuffle, int deflate,
                   int deflate_level);
extern int
ncmpi_inq_var_deflate(int ncid, int varid, int *shufflep,
                   int *deflatep, int *deflate_levelp);
extern int
ncmpi_inq_var_szip(int ncid, int varid, int *options_maskp, int *pixels_per_blockp);

/* Set fletcher32 checksum for a var. This must be done after nc_def_var
 *    and before nc_enddef. */
extern int
ncmpi_def_var_fletcher32(int ncid, int varid, int fletcher32);

/* Inquire about fletcher32 checksum for a var. */
extern int
ncmpi_inq_var_fletcher32(int ncid, int varid, int *fletcher32p);



namespace PnetCDF
{
  /*!
    Function checks error code and if necessary throws an exception.
    \param retCode Integer value returned by %netCDF C-routines.
    \param file    The name of the file from which this call originates.
    \param line    The line number in the file from which this call originates.
  */
  void ncmpiCheck(int retCode, const char* file, int line);

  /*!
    Function checks if the file (group) is in define mode.
    If not, it places it in the define mode.
    While this is automatically done by the underlying C API
    for netCDF-4 files, the netCDF-3 files still need this call.
  */
  void ncmpiCheckDefineMode(int ncid);

  /*!
    Function checks if the file (group) is in data mode.
    If not, it places it in the data mode.
    While this is automatically done by the underlying C API
    for netCDF-4 files, the netCDF-3 files still need this call.
  */
  void ncmpiCheckDataMode(int ncid);

};




namespace PnetCDF
{
  class NcmpiGroup; // forward declaration to avoid cyclic reference.

  /*! Base class inherited by NcOpaque, NcVlen, NcCompound and NcEnum classes. */
  class NcmpiType
  {

  public:

    /*!
      List of netCDF types that can be represented.
      The enumeration list contains the complete set of netCDF variable types. In addition, the type NC_TYPE
      is included. This enables the user to instantiate a netCDF type object without explcitly needing to know
      it precise type.
    */
    enum ncmpiType
    {
      ncmpi_BYTE     = NC_BYTE, 	//!< signed 1 byte integer
      ncmpi_CHAR     = NC_CHAR,		//!< ISO/ASCII character
      ncmpi_SHORT    = NC_SHORT, 	//!< signed 2 byte integer
      ncmpi_INT      = NC_INT,		//!< signed 4 byte integer
      ncmpi_FLOAT    = NC_FLOAT, 	//!< single precision floating point number
      ncmpi_DOUBLE   = NC_DOUBLE, 	//!< double precision floating point number
      ncmpi_UBYTE    = NC_UBYTE,	//!< unsigned 1 byte int
      ncmpi_USHORT   = NC_USHORT,	//!< unsigned 2-byte int
      ncmpi_UINT     = NC_UINT,		//!< unsigned 4-byte int
      ncmpi_INT64    = NC_INT64,	//!< signed 8-byte int
      ncmpi_UINT64   = NC_UINT64,	//!< unsigned 8-byte int

      // PnetCDF does not support types below
      ncmpi_STRING   = NC_STRING, 	//!< string
      ncmpi_VLEN     = NC_VLEN,   	//!< "NcVlen type"
      ncmpi_OPAQUE   = NC_OPAQUE, 	//!< "NcOpaque type"
      ncmpi_ENUM     = NC_ENUM, 	//!< "NcEnum type"
      ncmpi_COMPOUND = NC_COMPOUND	//!< "NcCompound type"
    };

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiType();

    /*!
      Constructor for a non-global type.
      This object describes the "essential" information for all netCDF types required by NcmpiVar, NcmpiAtt objects.
      New netCDF types can be added using the appropriate "add" method in the NcmpiGroup object.
      \param grp    Parent NcmpiGroup object.
      \param name   Name of this type.
    */
    NcmpiType(const PnetCDF::NcmpiGroup& grp, const std::string& name);


    /*!
      Constructor for a non-global type.
      This object describes the "essential" information for all netCDF types required by NcmpiVar, NcmpiAtt objects.
      New netCDF types can be added using the appropriate "add" method in the NcmpiGroup object.
      \param grp    Parent NcmpiGroup object.
      \param id     type id
    */
    NcmpiType(const PnetCDF::NcmpiGroup& grp, nc_type id);

    /*!
      Constructor for a global type
      This object describes the "essential" information for a netCDF global type.
      \param id     type id
    */
    NcmpiType(nc_type id);

    /*! The copy constructor. */
    NcmpiType(const NcmpiType& rhs);

    /*! destructor  */
    virtual ~NcmpiType() {}

    /*! equivalence operator */
    bool operator==(const NcmpiType&) const;

    /*!  != operator */
    bool operator!=(const NcmpiType &) const;

    // accessors to private data.
    /*! The netCDF Id of this type. */
    nc_type getId() const {return myId;}

    /*! Gets parent group. For an atomic type, returns a Null object.*/
    PnetCDF::NcmpiGroup getParentGroup() const;

    /*!
      The name of this type. For atomic types, the CDL type names are returned. These are as follows:
        - NcmpiByte   String returned is "byte".
        - NcmpiUbyte  String returned is "ubyte".
        - NcmpiChar   String returned is "char".
        - NcmpiShort  String returned is "short".
        - NcmpiUshort String returned is "ushort".
        - NcmpiInt    String returned is "int".
        - NcmpiUint   String returned is "uint".
        - NcmpiInt64  String returned is "int64".
        - NcmpiUint64 String returned is "uint64".
        - NcmpiFloat  String returned is "float".
        - NcmpiDouble String returned is "double".
     */
    std::string getName() const;

    /*!
      The size in bytes.
      This function will work on any type, including atomic and any user defined type, whether
      compound, opaque, enumeration, or variable length array.
     */
    MPI_Offset getSize() const;

    /*!
      The type class returned as enumeration type.
      Valid for all types, whether atomic or user-defined. User-defined types are returned as one of the following
      enumeration types: ncmpi_VLEN, ncmpi_OPAQUE, ncmpi_ENUM, or ncmpi_COMPOUND.
     */
    ncmpiType getTypeClass() const;

    /*!
      Return a string containing the name of the enumerated type.  (ie one of the following strings:
      "ncmpi_BYTE", "ncmpi_CHAR", "ncmpi_SHORT", "ncmpi_INT", "ncmpi_FLOAT", "ncmpi_DOUBLE", "ncmpi_UBYTE", "ncmpi_USHORT",
      "ncmpi_UINT", "ncmpi_INT64", "ncmpi_UINT64", "ncmpi_STRING", "ncmpi_VLEN", "ncmpi_OPAQUE", "ncmpi_ENUM", "ncmpi_COMPOUND"
     */
    std::string getTypeClassName() const;

    /*! Returns true if this object is null (i.e. it has no contents); otherwise returns false. */
    bool isNull() const  {return nullObject;}

    /*! comparator operator  */
    friend bool operator<(const NcmpiType& lhs,const NcmpiType& rhs);

    /*! comparator operator  */
    friend bool operator>(const NcmpiType& lhs,const NcmpiType& rhs);

  protected:

    /*! assignment operator  */
    NcmpiType& operator=(const NcmpiType& rhs);

    bool nullObject;

    /*! the type Id */
    nc_type myId;

    /*! the group Id */
    int groupId;

  };

}



namespace PnetCDF
{

  /*! Abstract base class represents inherited by ncmpiVarAtt and ncmpiGroupAtt. */
  class NcmpiAtt
  {
  public:

    /*! destructor */
    virtual ~NcmpiAtt()=0;

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiAtt ();

    /*! Constructor for non-null instances. */
    NcmpiAtt(bool nullObject);

    /*! The copy constructor. */
    NcmpiAtt(const NcmpiAtt& rhs);

    /*! Get the attribute name. */
    std::string getName() const {return myName;}

    /*! Gets attribute length. */
    MPI_Offset  getAttLength() const;

    /*! Returns the attribute type. */
    NcmpiType  getType() const;

    /*! Gets parent group. */
    NcmpiGroup  getParentGroup() const;

    /*! equivalence operator */
    bool operator== (const NcmpiAtt& rhs) const;

    /*!  != operator */
    bool operator!=(const NcmpiAtt& rhs) const;

    /*! \overload
     */
    void getValues(char* dataValues) const;
    /*! \overload
     */
    void getValues(unsigned char* dataValues) const;
    /*! \overload
     */
    void getValues(signed char* dataValues) const;
    /*! \overload
     */
    void getValues(short* dataValues) const;
    /*! \overload
     */
    void getValues(int* dataValues) const;
    /*! \overload
     */
    void getValues(long* dataValues) const;
    /*! \overload
     */
    void getValues(float* dataValues) const;
    /*! \overload
     */
    void getValues(double* dataValues) const;
    /*! \overload
     */
    void getValues(unsigned short* dataValues) const;
    /*! \overload
     */
    void getValues(unsigned int* dataValues) const;
    /*! \overload
     */
    void getValues(long long* dataValues) const;
    /*! \overload
     */
    void getValues(unsigned long long* dataValues) const;
    /*! \overload
     */
    void getValues(char** dataValues) const;

    /*! \overload
      (The string variable does not need preallocating.)
     */
    void getValues(std::string& dataValues) const;

    /*!
      Gets a netCDF attribute.
      The user must ensure that the variable "dataValues" has sufficient space to hold the attribute.
      \param  dataValues On return contains the value of the attribute.
      If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getValues(void* dataValues) const;

    /*! Returns true if this object is null (i.e. it has no contents); otherwise returns false. */
    bool isNull() const {return nullObject;}

  protected:
    /*! assignment operator */
    NcmpiAtt& operator= (const NcmpiAtt& rhs);

    bool nullObject;

    std::string myName;

    int groupId;

    int varId;

  };

}





namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.

  /*! Class represents a netCDF enum type */
  class NcmpiEnumType : public NcmpiType
    {
    public:

      /*! List of NetCDF-4 Enumeration types.*/
      enum ncmpiEnumType	{
	ncmpi_BYTE     = NC_BYTE, 	//!< signed 1 byte integer
	ncmpi_SHORT    = NC_SHORT, 	//!< signed 2 byte integer
	ncmpi_INT      = NC_INT,	//!< signed 4 byte integer
	ncmpi_UBYTE    = NC_UBYTE,	//!< unsigned 1 byte int
	ncmpi_USHORT   = NC_USHORT,	//!< unsigned 2-byte int
	ncmpi_UINT     = NC_UINT,	//!< unsigned 4-byte int
	ncmpi_INT64    = NC_INT64,	//!< signed 8-byte int
	ncmpi_UINT64   = NC_UINT64	//!< unsigned 8-byte int
      };

      /*! Constructor generates a \ref isNull "null object". */
      NcmpiEnumType();

      /*!
	Constructor.
	The enum Type must already exist in the netCDF file. New netCDF enum types can
	be added using NcmpiGroup::addNcmpiEnumType();
	\param grp        The parent group where this type is defined.
	\param name       Name of new type.
      */
      NcmpiEnumType(const NcmpiGroup& grp, const std::string& name);

      /*!
	Constructor.
	Constructs from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of an Enum type.
	\param ncmpiType     A Nctype object.
      */
      NcmpiEnumType(const NcmpiType& ncmpiType);

      /*! assignment operator */
      NcmpiEnumType& operator=(const NcmpiEnumType& rhs);

      /*!
	Assignment operator.
       This assigns from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of an Enum type.
      */
      NcmpiEnumType& operator=(const NcmpiType& rhs);

      /*! The copy constructor. */
      NcmpiEnumType(const NcmpiEnumType& rhs);

      /*! Destructor */
      ~NcmpiEnumType(){}


      /*!
	Adds a new member to this NcmpiEnumType type.
	\param name         Name for this new Enum memebr.
	\param memberValue  Member value, must be of the correct NcmpiType.
      */
      template <class T> void addMember(const std::string& name, T memberValue)
      {
	ncmpiCheck(ncmpi_insert_enum(groupId, myId, name.c_str(), (void*) &memberValue),__FILE__,__LINE__);
      }

      /*! Returns number of members in this NcmpiEnumType object. */
      MPI_Offset  getMemberCount() const;

      /*! Returns the member name for the given zero-based index. */
      std::string  getMemberNameFromIndex(int index) const;

      /*! Returns the member name for the given NcmpiEnumType value. */
      template <class T>  std::string  getMemberNameFromValue(const T memberValue) const {
	char charName[NC_MAX_NAME+1];
	ncmpiCheck(ncmpi_inq_enum_ident(groupId,myId,static_cast<long long>(memberValue),charName),__FILE__,__LINE__);
	return std::string(charName);
      }

      /*!
	Returns the value of a member with the given zero-based index.
	\param name         Name for this new Enum member.
	\param memberValue  Member value, returned by this routine.
      */
      template <class T> void getMemberValue(int index, T& memberValue) const
	{
	  char* charName=NULL;
	  ncmpiCheck(ncmpi_inq_enum_member(groupId,myId,index,charName,&memberValue),__FILE__,__LINE__);
	}

      /*! Returns the base type. */
      NcmpiType  getBaseType() const;

  };

}



namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.

  /*! Class represents a netCDF group attribute */
  class NcmpiGroupAtt : public NcmpiAtt
  {
  public:

    /*! assignment operator */
    NcmpiGroupAtt& operator= (const NcmpiGroupAtt& rhs);

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiGroupAtt ();

    /*! The copy constructor. */
    NcmpiGroupAtt(const NcmpiGroupAtt& rhs) ;

    /*!
      Constructor for an existing global attribute.
      \param  grp        Parent Group object.
      \param  index      The index (id) of the attribute.
    */
    NcmpiGroupAtt(const NcmpiGroup& grp, const int index);

    /*! equivalence operator */
    bool operator== (const NcmpiGroupAtt& rhs);

    /*! comparator operator */
    friend bool operator<(const NcmpiGroupAtt& lhs,const NcmpiGroupAtt& rhs);

    /*! comparator operator */
    friend bool operator>(const NcmpiGroupAtt& lhs,const NcmpiGroupAtt& rhs);

  };

}






namespace PnetCDF
{
  class NcmpiVar;          // forward declaration.
  class NcmpiDim;          // forward declaration.
  class NcmpiVlenType;     // forward declaration.
  class NcmpiCompoundType; // forward declaration.
  class NcmpiOpaqueType;   // forward declaration.

  /*! Class represents a netCDF group. */
  class NcmpiGroup
  {

  public:

    /*!
      The enumeration list contains the options for selecting groups (used for returned set of NcmpiGroup objects).
    */
    enum GroupLocation
      {
	ChildrenGrps,              //!< Select from the set of children in the current group.
	ParentsGrps,               //!< Select from set of parent groups (excludes the current group).
	ChildrenOfChildrenGrps,    //!< Select from set of all children of children in the current group.
	AllChildrenGrps,           //!< Select from set of all children of the current group and beneath.
	ParentsAndCurrentGrps,     //!< Select from set of parent groups(includes the current group).
	AllGrps                    //!< Select from set of parent groups, current groups and all the children beneath.
      };

    /*!
      The enumeration list contains the options for selecting groups.
    */
    enum Location
      {
	Current,            //!< Select from contents of current group.
	Parents,            //!< Select from contents of parents groups.
	Children,           //!< Select from contents of children groups.
	ParentsAndCurrent,  //!< Select from contents of current and parents groups.
	ChildrenAndCurrent, //!< Select from contents of current and child groups.
	All                 //!< Select from contents of current, parents and child groups.
      };


    /*! assignment operator  */
    NcmpiGroup& operator=(const NcmpiGroup& rhs);

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiGroup();

    //* constructor */
    NcmpiGroup(int groupId);

    /*! The copy constructor. */
    NcmpiGroup(const NcmpiGroup& rhs);

    /*! destructor  */
    virtual ~NcmpiGroup();

    /*! equivalence operator */
    bool operator==(const NcmpiGroup& rhs) const;

    /*!  != operator */
    bool operator!=(const NcmpiGroup& rhs) const;

    /*! comparator operator  */
    friend bool operator<(const NcmpiGroup& lhs,const NcmpiGroup& rhs);

    /*! comparator operator  */
    friend bool operator>(const NcmpiGroup& lhs,const NcmpiGroup& rhs);

    // /////////////
    // NcmpiGroup-related methods
    // /////////////

    /*! Gets the group name. */
    /*!
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
      \param fullName If true then the full name is returned with subgroups separated by a forward slash "/" (default is false)
      \return         The group name.
    */
    std::string getName(bool fullName=false) const;

    /*!
      Gets the parent group.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the  group is null (ie NcmpiGroup::isNull()=true).
      If the current root is the parent group, then return a null group.
    */
    NcmpiGroup getParentGroup() const ;

    /*!
      Gets the group id.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
    */
    int  getId() const;

    /*!
      Gets the number of  NcmpiGroup objects.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
      \param location Enumeration type controlling the groups to search.
      \return         Number of groups.
    */
    int getGroupCount(NcmpiGroup::GroupLocation location=ChildrenGrps) const;

    /*!
      Gets the collection of NcmpiGroup objects.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
      \param location Enumeration type controlling the groups to search.
      \return         A STL multimap object, containing pairs of <attribute name, NcmpiGroup object> entities.
    */
    std::multimap<std::string,NcmpiGroup> getGroups(NcmpiGroup::GroupLocation location=ChildrenGrps) const;


    /*!
      Gets NcmpiGroup objects with a given name.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
      \param name     Name of group.
      \param location Enumeration type controlling the groups to search.
      \return         Set of NcmpiGroup objects with given name.
    */
    std::set<NcmpiGroup> getGroups(const std::string& name,NcmpiGroup::GroupLocation location=ChildrenGrps) const;

    /*!
      Gets the named child NcmpiGroup object.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
      \param name  Group name.
      \param location   Enumeration type controlling the groups to search.
      \return      An NcmpiGroup object. If there are multiple objects indentied with the same name,
      the object closest to the current group is returned. If no valid object is found ,
      a \ref NcmpiGroup::isNull "null node" is returned.
    */
    NcmpiGroup getGroup(const std::string& name,NcmpiGroup::GroupLocation location=ChildrenGrps) const;

    /*!
      Adds a new child netCDF group object.
      Method will throw an PnetCDF::exceptions::NcNullgrp exception if the group is null (ie NcmpiGroup::isNull()=true).
      \param   name     Variable name.
      \return  NcmpiGroup  The NcmpiGroup object for this new netCDF group.
    */
    NcmpiGroup addGroup(const std::string& name) const;


    /*! Returns true if this object is null (i.e. it has no contents); otherwise returns false. */
    bool isNull() const  {return nullObject;}

    /*! Returns true if this is the root group, otherwise returns false. */
    bool isRootGroup() const;

    // /////////////
    // NcmpiVar-related accessors
    // /////////////

    /*!
      Gets the number of NcmpiVar objects in this group.
      \param location Enumeration type controlling the groups to search.
      \return         Number of variables.
    */
    int getVarCount(NcmpiGroup::Location location=Current) const;

    /*!
      Gets the number of record variable NcmpiVar objects in this group.
      \param location Enumeration type controlling the groups to search.
      \return         Number of record variables.
    */
    int getRecVarCount(NcmpiGroup::Location location=Current) const;

    /*!
      Gets the size of record block, i.e. the sume of single records of all
      the record variables.
      \param location Enumeration type controlling the groups to search.
      \return         size of record bock.
    */
    MPI_Offset getRecSize(NcmpiGroup::Location location=Current) const;

    /*!
      Gets the number of fixed-size variable NcmpiVar objects in this group.
      \param location Enumeration type controlling the groups to search.
      \return         Number of fixed-size variables.
    */
    int getFixVarCount(NcmpiGroup::Location location=Current) const;

    /*!
      Get the collection of NcmpiVar objects.
      \param location Enumeration type controlling the groups to search.
      \return         A STL multimap object, containing pairs of <attribute name, NcmpiVar object> entities.
    */
   std::multimap<std::string,NcmpiVar> getVars(NcmpiGroup::Location location=Current) const;

   /*!
     Gets all NcmpiVar objects with a given name.
      \param name     Name of attribute
      \param location Enumeration type controlling the groups to search.
      \return         Set of NcmpiVar objects.
    */
    std::set<NcmpiVar> getVars(const std::string& name,NcmpiGroup::Location location=Current) const;

    /*!
      Gets the named NcmpiVar object..
      \param name     Variable name.
      \param location Enumeration type controlling the groups to search.
      \return         A NcmpiVar object. If there are multiple objects indentied with the
      same name, the object closest  to the current group is returned.
      If no valid object is found , a \ref NcmpiVar::isNull "null node" is returned.
     */
    NcmpiVar getVar(const std::string& name,NcmpiGroup::Location location=Current) const;

    /*!
      Adds a new netCDF scalar variable.
      The NcmpiType must be non-null, and be defined in either the current group or a parent group.
      An NcNullType exception is thrown if the NcmpiType object is invalid.
      \param    name     Variable name.
      \param   typeName  Type name.
      \return            The NcmpiVar object for this new netCDF variable.
    */
    NcmpiVar addVar(const std::string& name, const NcmpiType& ncmpiType) const;

    /*!
      Adds a new netCDF variable.
      The NcmpiType and NcmpiDim objects must be non-null, and be defined in either the current group or a parent group.
      An NcNullType exception is thrown if the NcmpiType object is invalid.
      An NcNullDim exception is thrown if the NcmpiDim object is invalid.
      \param    name     Variable name.
      \param   typeName  Type name.
      \param   dimName   Dimension name.
      \return            The NcmpiVar object for this new netCDF variable.
    */
    NcmpiVar addVar(const std::string& name, const std::string& typeName, const std::string& dimName) const;

    /*!
      Adds a new netCDF variable.
      The NcmpiType and NcmpiDim objects must be non-null, and be defined in either the current group or a parent group.
      An NcNullType exception is thrown if the NcmpiType object is invalid.
      An NcNullDim exception is thrown if the NcmpiDim object is invalid.
      \param    name      Variable name.
      \param    ncmpiType    NcmpiType object.
      \param    ncmpiDim     NcmpiDim object.
      \return             The NcmpiVar object for this new netCDF variable.
    */
    NcmpiVar addVar(const std::string& name, const NcmpiType& ncmpiType, const NcmpiDim& ncmpiDim) const;

    /*!
      Adds a new netCDF multi-dimensional variable.
      The NcmpiType and NcmpiDim objects must be non-null, and be defined in either the current group or a parent group.
      An NcNullType exception is thrown if the NcmpiType object is invalid.
      An NcNullDim exception is thrown if the NcmpiDim object is invalid.
      \param   name     Variable name.
      \param   typeName Type name.
      \param   dimNames Vector of dimension names.
      \return           The NcmpiVar object for this new netCDF variable.
    */
    NcmpiVar addVar(const std::string& name, const std::string& typeName, const std::vector<std::string>& dimNames) const;


    /*!
      Adds a new multi-dimensional netCDF variable.
      The NcmpiType and NcmpiDim objects must be non-null, and be defined in either the current group or a parent group.
      An NcNullType exception is thrown if the NcmpiType object is invalid.
      An NcNullDim exception is thrown if any of the the NcmpiDim objects are invalid.
      \param    name        Variable name.
      \param    ncmpiType      NcmpiType object.
      \param    ncmpiDimvector Vector of NcmpiDim objects.
      \return               The NcmpiVar object for this new netCDF variable.
    */
    NcmpiVar addVar(const std::string& name, const NcmpiType& ncmpiType, const std::vector<NcmpiDim>& ncmpiDimVector) const;

    // /////////////
    // NcmpiGroupAtt-related methods
    // /////////////

    /*!
      Gets the number of group attributes.
      \param location Enumeration type controlling the groups to search.
      \return         Number of attributes.
    */
    int getAttCount(NcmpiGroup::Location location=Current) const;

    /*!
      Gets the collection of NcmpiGroupAtt objects.
      \param location Enumeration type controlling the groups to search.
      \return         A STL multimap object, containing pairs of <attribute name, NcmpiGroupAtt object> entities.
    */
    std::multimap<std::string,NcmpiGroupAtt> getAtts(NcmpiGroup::Location location=Current) const;

    /*!
    Gets all NcmpiGroupAtt objects with a given name.
      \param name     Name of attribute
      \param location Enumeration type controlling the groups to search.
      \return         Set of NcmpiGroupAtt objects.
    */
    std::set<NcmpiGroupAtt> getAtts(const std::string& name,NcmpiGroup::Location location=Current) const;

    /*!
      Gets the named NcmpiGroupAtt object.
      \param name     Name of attribute
      \param location Enumeration type controlling the groups to search.
      \return         A NcmpiGroupAtt object. If there are multiple objects indentied with the
      same name, the object closest  to the current group is returned.  If no valid object is found ,
      a \ref NcmpiGroupAtt::isNull "null node" is returned.
    */
    NcmpiGroupAtt getAtt(const std::string& name,NcmpiGroup::Location location=Current) const;


    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, MPI_Offset len, const char** dataValues) const ;

    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const std::string& dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, short datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, int datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, long datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, float datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, double datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, unsigned short datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, unsigned int datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, unsigned long long datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, long long datumValue) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned char* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const signed char* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const short* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const int* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const long* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const float* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const double* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned short* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned int* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned long long* dataValues) const ;
    /*! \overload
     */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const long long* dataValues) const ;
    /*!
      Creates a new NetCDF group attribute or if already exisiting replaces it.
      If you are writing a _Fill_Value_ attribute, and will tell the HDF5 layer to use
      the specified fill value for that variable.
      \par
      Although it's possible to create attributes of all types, text and double attributes are adequate for most purposes.
      \param name        Name of attribute.
      \param type    The attribute type.
      \param len         The length of the attribute (number of Nctype repeats).
      \param dataValues  Data Values to put into the new attribute.
      If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
      \return            The NcmpiGroupAtt object for this new netCDF attribute.
    */
    NcmpiGroupAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const void* dataValues) const ;



    // /////////////
    // NcmpiDim-related methods
    // /////////////

    /*!
      Gets the number of NcmpiDim objects.
      \param location Enumeration type controlling the groups to search.
      \return         Number of dimensions.
    */
    int getDimCount(NcmpiGroup::Location location=Current) const;

    /*!
      Gets the collection of NcmpiDim objects.
      \param location Enumeration type controlling the groups to search.
      \return         A STL multimap object, containing pairs of <attribute name, NcmpiDim object> entities.
    */
    std::multimap<std::string,NcmpiDim> getDims(NcmpiGroup::Location location=Current) const;

    /*!
      Gets NcmpiDim objects with a given name.
      \param name     Name of dimension.
      \param location Enumeration type controlling the groups to search.
      \return         Set of NcmpiDim objects with given name.
    */
    std::set<NcmpiDim> getDims(const std::string& name,NcmpiGroup::Location location=Current) const;

    /*!
      Gets the named NcmpiDim object.
      \param name       Name of dimension.
      \param location   Enumeration type controlling the groups to search.
      \return           An NcmpiDim object. If there are multiple objects indentied with the same name,
      the object closest to the current group is returned. If no valid object is found , a \ref NcmpiDim::isNull "null node" is returned.
    */
    NcmpiDim getDim(const std::string& name,NcmpiGroup::Location location=Current) const;

    /*!
      Adds a new netCDF dimension.
      \param The name of new dimension.
      \param Length of dimension; that is, number of values for this dimension as an index to variables
      that use it.
      \return   The NcmpiDim object for this new netCDF dimension.
    */
    NcmpiDim addDim(const std::string& name, MPI_Offset dimSize) const;

    /*!
      Adds a new unlimited netCDF dimension.
      \param The name of new dimension.
      \return   The NcmpiDim object for this new netCDF dimension.
    */
    NcmpiDim addDim(const std::string& name) const;

    // /////////////
    // NcmpiType-related methods
    // /////////////

    /*!
      Gets the number of type objects.
      \param location Enumeration type controlling the groups to search.
      \return         Number of types.
    */
    int getTypeCount(NcmpiGroup::Location location=Current) const;


    /*!
      Gets the number of type objects with a given enumeration type.
      \param enumType The enumeration value of the object type.
      \param location Enumeration type controlling the groups to search.
      \return         Number of types of the given enumeration type.
    */
    int getTypeCount(NcmpiType::ncmpiType enumType, NcmpiGroup::Location location=Current) const;


    /*!
      Gets the collection of NcmpiType objects.
      \param location Enumeration type controlling the groups to search.
      \return         A STL multimap object, on return contains pairs of <Type name, NcmpiType object> entities.
                      For atomic types, the type returned is the CDL name.
    */
    std::multimap<std::string,NcmpiType> getTypes(NcmpiGroup::Location location=Current) const;


    /*!
      Gets the collection of NcmpiType objects with a given name.
      \param name     Name of type. For atomic types, the CDL name is expected. This is consistent with the
                         string returned from NcmpiType::getName().
      \param location Enumeration type controlling the groups to search.
      \return         Set of  NcmpiType objects.
    */
    std::set<NcmpiType> getTypes(const std::string& name, NcmpiGroup::Location location=Current) const;

    /*!
      Gets the collection of NcmpiType objects with a given data type.
      \param enumType Enumeration type specifying the data type.
      \param location Enumeration type controlling the groups to search.
      \return         Set of Nctype objects.
    */
    std::set<NcmpiType> getTypes(NcmpiType::ncmpiType enumType, NcmpiGroup::Location location=Current) const;


    /*!
      Gets the collection of NcmpiType objects with a given name and data type.
      \param name     Name of type. For atomic types, the CDL name is expected. This is consistent with the
                         string returned from NcmpiType::getName().
      \param enumType Enumeration type specifying the data type.
      \param location Enumeration type controlling the groups to search.
      \return         Set of Nctype objects.
    */
    std::set<NcmpiType> getTypes(const std::string& name, NcmpiType::ncmpiType enumType, NcmpiGroup::Location location=Current) const;


    /*!
      Gets the NcmpiType object with a given name.
      \param name     Name of type. For atomic types, the CDL name is expected. This is consistent with the
                         string returned from NcmpiType::getName().
      \param location Enumeration type controlling the groups to search.
      \return         NcmpiType object. If there are multiple objects indentied with the same name,
      the object closest to the current group is returned.  If no valid object is found , a \ref NcmpiType::isNull "null node" is returned.

    */
    NcmpiType getType(const std::string& name, NcmpiGroup::Location location=Current) const;


    /*!
      Adds a new netCDF enum type.
      \param name        Name of type. For atomic types, the CDL name is expected. This is consistent with the
                         string returned from NcmpiType::getName().
      \param enumType    The enumeration value of the object type.
      \return            The NcmpiEnumType object for this new netCDF enum type.
    */
    NcmpiEnumType addEnumType(const std::string& name,NcmpiEnumType::ncmpiEnumType basetype) const;


    /*!
      Adds a new netCDF Vlen type.
      \param name        Name of type.
      \param basetype    A NcmpiType object to be used for the basetype.
      \return            The NcmpiVlenType object for this new netCDF vlen type.
    */
    NcmpiVlenType addVlenType(const std::string& name,NcmpiType& basetype) const;


    /*!
      Adds a new netCDF Opaque type.
      \param name     Name of type.
      \param size     The size of the new type in bytes.
      \return         The NcmpiOpaqueType object for this new netCDF opaque type..
    */
    NcmpiOpaqueType addOpaqueType(const std::string& name, MPI_Offset size) const;


    /*!
      Adds a new netCDF UserDefined type.
      \param name     Name of type.
      \param size     The size of the new type in bytes.
      \return         The new NcmpiCompoundType object for this new netCDF userDefined type.
    */
    NcmpiCompoundType addCompoundType(const std::string& name, MPI_Offset size) const;


    /*!
      Gets a collection of  coordinate variables.
      Coordinate variable have  an NcmpiDim and NcmpiVar object with the same name defined in the same group.
      \par
      The method returns STL map object containing a coordinate variables in the current group  and optionally
      in the parent and child groups. It is expected that within each group, the names of dimensions are unique and
      the the names of variables are unique. However, if this is not the case, this method will still work correctly.

      \param location Enumeration type controlling the groups to search.
      \return         The NcmpiVar dimension variable. If no valid object is found , a \ref NcmpiVar::isNull "null node" is returned.
    std::map<std::string,NcmpiGroup> getCoordVars(NcmpiGroup::Location location=Current) const;
    */

    /*!
      Gets the NcmpiDim and NcmpiVar object pair for a named coordinate variable.
      Coordinate variable have  an NcmpiDim and NcmpiVar object with the same name defined in the same group.
      \par
      The method returns two objects for the named coordinate variable. The method searches first in the current
      group and optionally in the parent and child group and returns the first instance found.
      \param location Enumeration type controlling the groups to search.
      \return         The set of names of dimension variables.
    void getCoordVar(std::string& coordVarName, NcmpiDim& ncmpiDim, NcmpiVar& ncmpiVar, NcmpiGroup::Location location=Current) const;
    */


  protected:

    /*! assignment operator  */
    /* NcmpiGroup& operator=(const NcmpiGroup& rhs); */

    bool nullObject;

    int myId;

  };

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Byte type. */
  class NcmpiByte : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiByte & rhs);

    /*! storage size */
    int sizeoff();

    ~NcmpiByte();

    /*! Constructor */
    NcmpiByte();
  };

  /*! A global instance  of the NcmpiByte class within the netCDF namespace. */
  extern NcmpiByte ncmpiByte;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Char type. */
  class NcmpiChar : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiChar & rhs);

    ~NcmpiChar();

    /*! Constructor */
    NcmpiChar();
  };

  /*! A global instance  of the NcmpiChar class within the netCDF namespace. */
  extern NcmpiChar ncmpiChar;

}



namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.

  /*!
    Class represents a netCDF compound type
  */
  class NcmpiCompoundType : public NcmpiType
  {
  public:

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiCompoundType();

    /*!
      Constructor.
      The compound Type must already exist in the netCDF file. New netCDF compound types can be
      added using NcmpiGroup::addNcmpiCompoundType();
      \param grp        The parent group where this type is defined.
      \param name       Name of new type.
    */
    NcmpiCompoundType(const NcmpiGroup& grp, const std::string& name);

    /*!
      Constructor.
      Constructs from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of a Compound type.
      \param ncmpiType     A Nctype object.
    */
    NcmpiCompoundType(const NcmpiType& ncmpiType);

    /*! assignment operator */
    NcmpiCompoundType& operator=(const NcmpiCompoundType& rhs);

    /*!
      Assignment operator.
      This assigns from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of a Compound type.
    */
    NcmpiCompoundType& operator=(const NcmpiType& rhs);

    /*! The copy constructor. */
    NcmpiCompoundType(const NcmpiCompoundType& rhs);

    /*! equivalence operator */
    bool operator==(const NcmpiCompoundType & rhs);

    /*! destructor */
    ~NcmpiCompoundType(){;}


    /*!
      Adds a named field.
      \param memName       Name of new field.
      \param newMemberType The type of the new member.
      \param offset        Offset of this member in bytes, obtained by a call to offsetof. For example
the offset of a member "mem4" in structure struct1 is: offsetof(struct1,mem4).
    */
    void addMember(const std::string& memName, const NcmpiType& newMemberType,MPI_Offset offset);

    /*!
      Adds a named array field.
      \param memName       Name of new field.
      \param newMemberType The type of the new member.
      \param offset        Offset of this member in bytes, obtained by a call to offsetof. For example
                           the offset of a member "mem4" in structure struct1 is: offsetof(struct1,mem4).
      \param shape         The shape of the array field.
    */
    void addMember(const std::string& memName, const NcmpiType& newMemberType, MPI_Offset offset, const std::vector<int>& shape);


    /*! Returns number of members in this NcmpiCompoundType object. */
    MPI_Offset  getMemberCount() const;

    /*! Returns a NcmpiType object for a single member. */
    NcmpiType getMember(int memberIndex) const;

    /*! Returns the offset of the member with given index. */
    MPI_Offset getMemberOffset(const int index) const;

    /*!
      Returns the number of dimensions of a member with the given index.
      \param Index of member (numbering starts at zero).
      \return The number of dimensions of the field. Non-array fields have 0 dimensions.
    */
    int getMemberDimCount(int memberIndex) const;


    /*!
      Returns the shape of a given member.
      \param Index of member (numbering starts at zero).
      \return The size of the dimensions of the field. Non-array fields have 0 dimensions.
    */
    std::vector<int> getMemberShape(int memberIndex) const;

  };

}




namespace PnetCDF
{

  /*! Class represents a netCDF atomic Double type. */
  class NcmpiDouble : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiDouble & rhs);

    /*!  destructor */
    ~NcmpiDouble();

    /*! Constructor */
    NcmpiDouble();
  };

  /*! A global instance  of the NcmpiDouble class within the netCDF namespace. */
  extern NcmpiDouble ncmpiDouble;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Float type. */
  class NcmpiFloat : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiFloat & rhs);

    /*!  destructor */
    ~NcmpiFloat();

    /*! Constructor */
    NcmpiFloat();
  };

  /*! A global instance  of the NcmpiFloat class within the netCDF namespace. */
  extern NcmpiFloat ncmpiFloat;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Int type. */
  class NcmpiInt : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiInt & rhs);

    /*!  destructor */
    ~NcmpiInt();

    /*! Constructor */
    NcmpiInt();
  };

  /*! A global instance  of the NcmpiInt class within the netCDF namespace. */
  extern NcmpiInt ncmpiInt;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Int64 type. */
  class NcmpiInt64 : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiInt64 & rhs);

    /*!  destructor */
    ~NcmpiInt64();

    /*! Constructor */
    NcmpiInt64();
  };

  /*! A global instance  of the NcmpiInt64 class within the netCDF namespace. */
  extern NcmpiInt64 ncmpiInt64;

}



namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.

  /*! Class represents a netCDF opaque type */
  class NcmpiOpaqueType : public NcmpiType
  {
  public:

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiOpaqueType();

    /*!
      Constructor.
      The opaque Type must already exist in the netCDF file. New netCDF opaque types #
      can be added using NcmpiGroup::addNcmpiOpaqueType();
      \param grp        The parent group where this type is defined.
      \param name       Name of new type.
    */
    NcmpiOpaqueType(const NcmpiGroup& grp, const std::string& name);

    /*!
      Constructor.
      Constructs from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of a Opaque type.
      \param ncmpiType     A Nctype object.
    */
    NcmpiOpaqueType(const NcmpiType& ncmpiType);

    /*! assignment operator */
    NcmpiOpaqueType& operator=(const NcmpiOpaqueType& rhs);

    /*!
      Assignment operator.
      This assigns from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of an Opaque type.
    */
    NcmpiOpaqueType& operator=(const NcmpiType& rhs);

    /*! The copy constructor.*/
    NcmpiOpaqueType(const NcmpiOpaqueType& rhs);

    /*!  destructor */
    ~NcmpiOpaqueType(){;}

    /*! Returns the size of the opaque type in bytes. */
    MPI_Offset  getTypeSize() const;

  };

}



namespace PnetCDF
{

  /*! Class represents a netCDF atomic Short type. */
  class NcmpiShort : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiShort & rhs);

    /*! destructor */
    ~NcmpiShort();

    /*! Constructor */
    NcmpiShort();
  };

  /*! A global instance  of the NcmpiShort class within the netCDF namespace. */
  extern NcmpiShort ncmpiShort;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Ubyte type. */
  class NcmpiUbyte : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiUbyte & rhs);

    /*! destructor */
    ~NcmpiUbyte();

    /*! Constructor */
    NcmpiUbyte();
  };

  /*! A global instance  of the NcmpiUbyte class within the netCDF namespace. */
  extern NcmpiUbyte ncmpiUbyte;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Uint type. */
  class NcmpiUint : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiUint & rhs);

    /*! destructor */
    ~NcmpiUint();

    /*! Constructor */
    NcmpiUint();
  };

  /*! A global instance  of the NcmpiUint class within the netCDF namespace. */
  extern NcmpiUint ncmpiUint;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Uint64 type.*/
  class NcmpiUint64 : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiUint64 & rhs);

    /*! destructor */
    ~NcmpiUint64();

    /*! Constructor */
    NcmpiUint64();
  };

  /*! A global instance  of the NcmpiUint64 class within the netCDF namespace. */
  extern NcmpiUint64 ncmpiUint64;

}


namespace PnetCDF
{

  /*! Class represents a netCDF atomic Ushort type. */
  class NcmpiUshort : public NcmpiType
  {
  public:

    /*! equivalence operator */
    bool operator==(const NcmpiUshort & rhs);

    /*! destructor */
    ~NcmpiUshort();

    /*! Constructor */
    NcmpiUshort();
  };

  // declare that the class instance ncmpiUshort is known by all....
  extern NcmpiUshort ncmpiUshort;

}


namespace PnetCDF
{

  //!  Exception classes.
  /*!
    These exceptions are thrown if the netCDF-4 API encounters an error.
  */
  namespace exceptions
  {

    /*!
      Base object is thrown if a netCDF exception is encountered.
      An unsatisfactory return from a call to one of the netCDF C-routines
      generates an exception using an object inheriting this class.  All other netCDF-related
      errors  including those originating in the C++ binding, generates an NcmpiException.
    */
    class NcmpiException : public std::exception {
    public:
      //NcmpiException(const string& complaint,const char* fileName,int lineNumber);
      NcmpiException(const char* complaint,const char* fileName,int lineNumber);
      NcmpiException(int errorCode, const char* complaint,const char* fileName,int lineNumber);
      NcmpiException(const NcmpiException& e) throw();
      NcmpiException& operator=(const NcmpiException& e) throw();
      virtual ~NcmpiException() throw();
      const char* what() const throw();
      int errorCode() const throw();
    private:
      std::string* what_msg;
      int ec;
    };


    /*! Thrown if the specified netCDF ID does not refer to an open netCDF dataset. */
    class NcBadId : public NcmpiException
    {
    public:
      NcBadId(const char* complaint,const char* file,int line);
    };

    /*! Thrown if too many netcdf files are open. */
    class NcNFile : public NcmpiException
    {
    public:
      NcNFile(const char* complaint,const char* file,int line);
    };

    /*! Thrown if, having set NC_NOCLOBBER, the specified dataset already exists. */
    class NcExist : public NcmpiException
    {
    public:
      NcExist(const char* complaint,const char* file,int line);
    };

    /*! Thrown if not a netCDF id.  */
    class NcInvalidArg : public NcmpiException
    {
    public:
      NcInvalidArg(const char* complaint,const char* file,int line);
    };

    /*! Thrown if invalid argument. */
    class NcInvalidWrite : public NcmpiException
    {
    public:
      NcInvalidWrite(const char* complaint,const char* file,int line);
    };

    /*! Thrown if operation not allowed in data mode. */
    class NcNotInDefineMode : public NcmpiException
    {
    public:
      NcNotInDefineMode(const char* complaint,const char* file,int line);
    };

    /*! Thrown if operation not allowed in defined mode. */
    class NcInDefineMode : public NcmpiException
    {
    public:
      NcInDefineMode(const char* complaint,const char* file,int line);
    };

    /*!
      Index exceeds dimension bound.
      Exception may  be generated during operations to get or put  netCDF variable data.
      The exception is thrown if the specified indices were out of range for the rank of the
      specified variable. For example, a negative index or an index that is larger than
      the corresponding dimension length will cause an error.
    */
    class NcInvalidCoords : public NcmpiException
    {
    public:
      NcInvalidCoords(const char* complaint,const char* file,int line);
    };

    /*! Thrown if NC_MAX_DIMS is exceeded. */
    class NcMaxDims : public NcmpiException
    {
    public:
      NcMaxDims(const char* complaint,const char* file,int line);
    };

    /*! Thrown if string match to name is in use. */
    class NcNameInUse : public NcmpiException
    {
    public:
      NcNameInUse(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attribute is not found. */
    class NcNotAtt : public NcmpiException
    {
    public:
      NcNotAtt(const char* complaint,const char* file,int line);
    };

    /*! Thrown if Nc_MAX_ATTRS is exceeded. */
    class NcMaxAtts : public NcmpiException
    {
    public:
      NcMaxAtts(const char* complaint,const char* file,int line);
    };

    /*! Thrown if not a valid netCDF data type. */
    class NcBadType : public NcmpiException
    {
    public:
      NcBadType(const char* complaint,const char* file,int line);
    };

    /*! Thrown if an invalid dimension id or name. */
    class NcBadDim : public NcmpiException
    {
    public:
      NcBadDim(const char* complaint,const char* file,int line);
    };

    /*! Thrown if Nc_UNLIMITED is in the wrong index. */
    class NcUnlimPos : public NcmpiException
    {
    public:
      NcUnlimPos(const char* complaint,const char* file,int line);
    };

    /*! Thrown if NC_MAX_VARS is exceeded. */
    class NcMaxVars : public NcmpiException
    {
    public:
      NcMaxVars(const char* complaint,const char* file,int line);
    };

    /*! Thrown if variable is not found. */
    class NcNotVar : public NcmpiException
    {
    public:
      NcNotVar(const char* complaint,const char* file,int line);
    };

    /*! Thrown if the action is prohibited on the NC_GLOBAL varid. */
    class NcGlobal : public NcmpiException
    {
    public:
      NcGlobal(const char* complaint,const char* file,int line);
    };

    /*! Thrown if not a netCDF file. */
    class NcNotNCF : public NcmpiException
    {
    public:
      NcNotNCF(const char* complaint,const char* file,int line);
    };

    /*! Thrown if in FORTRAN, string is too short. */
    class NcSts : public NcmpiException
    {
    public:
      NcSts(const char* complaint,const char* file,int line);
    };

    /*! Thrown if NC_MAX_NAME is exceeded. */
    class NcMaxName : public NcmpiException
    {
    public:
      NcMaxName(const char* complaint,const char* file,int line);
    };

    /*! Thrown if NC_UNLIMITED size is already in use. */
    class NcUnlimit : public NcmpiException
    {
    public:
      NcUnlimit(const char* complaint,const char* file,int line);
    };

    /*! Thrown if ncmpi_rec op when there are no record vars. */
    class NcNoRecVars : public NcmpiException
    {
    public:
      NcNoRecVars(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attempt to convert between text and numbers. */
    class NcmpiChar : public NcmpiException
    {
    public:
      NcmpiChar(const char* complaint,const char* file,int line);
    };

    /*! Thrown if edge+start exceeds dimension bound. */
    class NcEdge : public NcmpiException
    {
    public:
      NcEdge(const char* complaint,const char* file,int line);
    };

    /*! Thrown if illegal stride. */
    class NcStride : public NcmpiException
    {
    public:
      NcStride(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attribute or variable name contains illegal characters. */
    class NcBadName : public NcmpiException
    {
    public:
      NcBadName(const char* complaint,const char* file,int line);
    };

    /*! Thrown if math result not representable. */
    class NcRange : public NcmpiException
    {
    public:
      NcRange(const char* complaint,const char* file,int line);
    };

    /*! Thrown if memory allocation (malloc) failure. */
    class NcNoMem : public NcmpiException
    {
    public:
      NcNoMem(const char* complaint,const char* file,int line);
    };

    /*! Thrown if one or more variable sizes violate format constraints */
    class NcmpiVarSize : public NcmpiException
    {
    public:
      NcmpiVarSize(const char* complaint,const char* file,int line);
    };

    /*! Thrown if invalid dimension size. */
    class NcmpiDimSize : public NcmpiException
    {
    public:
      NcmpiDimSize(const char* complaint,const char* file,int line);
    };

    /*! Thrown if file likely truncated or possibly corrupted. */
    class NcTrunc : public NcmpiException
    {
    public:
      NcTrunc(const char* complaint,const char* file,int line);
    };

    /*! Thrown if an error was reported by the HDF5 layer. */
    class NcHdfErr : public NcmpiException
    {
    public:
      NcHdfErr(const char* complaint,const char* file,int line);
    };

    /*! Thrown if cannot read. */
    class NcCantRead : public NcmpiException
    {
    public:
      NcCantRead(const char* complaint,const char* file,int line);
    };

    /*! Thrown if cannot write. */
    class NcCantWrite : public NcmpiException
    {
    public:
      NcCantWrite(const char* complaint,const char* file,int line);
    };

    /*! Thrown if cannot create. */
    class NcCantCreate : public NcmpiException
    {
    public:
      NcCantCreate(const char* complaint,const char* file,int line);
    };

    /*! Thrown if file meta. */
    class NcmpiFileMeta : public NcmpiException
    {
    public:
      NcmpiFileMeta(const char* complaint,const char* file,int line);
    };

    /*! Thrown if dim meta. */
    class NcmpiDimMeta : public NcmpiException
    {
    public:
      NcmpiDimMeta(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attribute meta. */
    class NcmpiAttMeta : public NcmpiException
    {
    public:
      NcmpiAttMeta(const char* complaint,const char* file,int line);
    };

    /*! Thrown if variable meta. */
    class NcmpiVarMeta : public NcmpiException
    {
    public:
      NcmpiVarMeta(const char* complaint,const char* file,int line);
    };

    /*! Thrown if no compound. */
    class NcNoCompound : public NcmpiException
    {
    public:
      NcNoCompound(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attribute exists. */
    class NcmpiAttExists : public NcmpiException
    {
    public:
      NcmpiAttExists(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attempting netcdf-4 operation on netcdf-3 file. */
    class NcNotNc4 : public NcmpiException
    {
    public:
      NcNotNc4(const char* complaint,const char* file,int line);
    };

    /*! Thrown if attempting netcdf-4 operation on strict nc3 netcdf-4 file. */
    class NcStrictNc3 : public NcmpiException
    {
    public:
      NcStrictNc3(const char* complaint,const char* file,int line);
    };

    /*! Thrown if bad group id. */
    class NcBadGroupId : public NcmpiException
    {
    public:
      NcBadGroupId(const char* complaint,const char* file,int line);
    };

    /*! Thrown if bad type id. */
    class NcBadTypeId : public NcmpiException
    {
    public:
      NcBadTypeId(const char* complaint,const char* file,int line);
    };

    /*! Thrown if bad field id. */
    class NcBadFieldId : public NcmpiException
    {
    public:
      NcBadFieldId(const char* complaint,const char* file,int line);
    };

    /*! Thrown if cannot find the field id. */
    class NcUnknownName : public NcmpiException
    {
    public:
      NcUnknownName(const char* complaint,const char* file,int line);
    };

    /*! Thrown if cannot return a netCDF group. */
    class NcEnoGrp : public NcmpiException
    {
    public:
      NcEnoGrp(const char* complaint,const char* file,int line);
    };

    /*!
      Thrown if the requested operation is on a NULL group.

      This exception is thrown if an operation on a NcmpiGroup object is requested which is empty. To test if the object is empty used NcmpiGroup::isNull()
     */
    class NcNullGrp : public NcmpiException
    {
    public:
      NcNullGrp(const char* complaint,const char* file,int line);
    };

    /*!
      Thrown if the requested operation is on a NULL type.

      This exception is thrown if an operation on a NcmpiType object is requested which is empty. To test if the object is empty used NcmpiType::isNull()
     */
    class NcNullType : public NcmpiException
    {
    public:
      NcNullType(const char* complaint,const char* file,int line);
    };

    /*!
      Thrown if the requested operation is on a NULL dimension.

      This exception is thrown if an operation on a NcmpiDim object is requested which is empty. To test if the object is empty used NcmpiDim::isNull()
     */
    class NcNullDim : public NcmpiException
    {
    public:
      NcNullDim(const char* complaint,const char* file,int line);
    };

    /*!
      Thrown if an operation to set the chunking, endianness, fill of a NcmpiVar object is issued after a
      call to NcmpiVar::getVar or NcmpiVar::putVar has been made.
    */
    class NcElateDef : public NcmpiException
    {
    public:
      NcElateDef(const char* complaint,const char* file,int line);
    };

  }

}





namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.

  /*! Class represents a netCDF dimension */
  class NcmpiDim   {

  public:

    /*! destructor*/
    ~NcmpiDim(){};

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiDim ();

    /*!
      Constructor for a dimension .
      The dimension must already exist in the netCDF file. New netCDF variables can be added using NcmpiGroup::addNcmpiDim();
      \param grp    Parent NcmpiGroup object.
      \param dimId  Id of the NcmpiDim object.
    */
    NcmpiDim(const NcmpiGroup& grp, int dimId);

    /*! assignment operator  */
    NcmpiDim& operator =(const NcmpiDim &);

    /*! equivalence operator */
    bool operator==(const NcmpiDim& rhs) const;

    /*!  != operator */
    bool operator!=(const NcmpiDim& rhs) const;

    /*! The copy constructor. */
    NcmpiDim(const NcmpiDim& ncmpiDim);

    /*! The name of this dimension.*/
    const std::string getName() const;

    /*! The netCDF Id of this dimension. */
    int getId() const {return myId;};

    /*! Gets a  NcmpiGroup object of the parent group. */
    NcmpiGroup getParentGroup() const;

    /*! Returns true if this is an unlimited dimension */
    bool isUnlimited() const;

    /*! The size of the dimension; for unlimited, this is the number of records written so far. */
    MPI_Offset  getSize() const;

    /*!renames the dimension */
    void rename( const std::string& newName);

    /*! Returns true if this object is null (i.e. it has no contents); otherwise returns false. */
    bool isNull() const  {return nullObject;}

    /*! comparator operator  */
    friend bool operator<(const NcmpiDim& lhs,const NcmpiDim& rhs);

    /*! comparator operator  */
    friend bool operator>(const NcmpiDim& lhs,const NcmpiDim& rhs);

  private:

    bool nullObject;

    int myId;

    int groupId;

  };

}





//!  C++ API for PnetCDF.
namespace PnetCDF
{

  /*!
    Class represents a netCDF root group.
    The Ncfile class is the same as the NcmpiGroup class with the additional
    functionality for opening and closing files.
   */
  class NcmpiFile : public NcmpiGroup
   {
   public:

      enum FileMode
	 {
	    read,	//!< File exists, open read-only.
	    write,      //!< File exists, open for writing.
	    replace,	//!< Create new file, even if already exists.
	    newFile	//!< Create new file, fail if already exists.
	 };

      enum FileFormat
         {
	    classic,    //!< Classic format, classic data model
	    classic2,   //!< 64-bit offset format, classic data model
	    nc4,        //!< (default) netCDF-4/HDF5 format, enhanced data model
	    nc4classic, //!< netCDF-4/HDF5 format, classic data model
	    classic5,   //!< CDF-5 format, classic data model
            BadFormat
         };

      enum FillMode
         {
            Fill = NC_FILL,      // prefill
            NoFill = NC_NOFILL,  // don't prefill
            Bad
         };

      /*! Constructor generates a \ref isNull "null object". */
      NcmpiFile();

      /*!
	Creates/opens a netCDF file.
	\param comm        MPI intra-communicator
	\param filePath    Name of netCDF optional path.
	\param fMode       The file mode:
	                    - 'read'    File exists, open for read-only.
	                    - 'write'   File exists, open for writing.
	                    - 'replace' Create new file, even it already exists.
	                    - 'newFile' Create new file, fail it exists already.
        \param info        MPI info object containing MPI and PnetCDF IO hints
      */
      NcmpiFile(const MPI_Comm    &comm,
                const std::string &filePath,
                FileMode           fMode,
                const MPI_Info    &info = MPI_INFO_NULL);

      /*!
	Creates a netCDF file of a specified format.
	\param comm        MPI intra-communicator
	\param filePath    Name of netCDF optional path.
	\param fMode       The file mode:
	                    - 'replace' Create new file, even it already exists.
	                    - 'newFile' Create new file, fail it exists already.
        \param info        MPI info object containing MPI and PnetCDF IO hints
      */
      NcmpiFile(const MPI_Comm    &comm,
                const std::string &filePath,
                FileMode           fMode,
                FileFormat         fFormat,
                const MPI_Info    &info = MPI_INFO_NULL);

      /*! destructor */
      virtual ~NcmpiFile(); //closes file and releases all resources

      //! Synchronize an open netcdf dataset to disk
      void sync();

      //! Flush data buffered by PnetCDF to disk
      void flush();

      //! Leave define mode, used for classic model
      void enddef();

      FileFormat getFormat( void ) const;

      void Wait_all(int num, int *array_of_requests, int *array_of_statuses);

      void Wait(int num, int *array_of_requests, int *array_of_statuses);

      void Cancel(int num, int *array_of_requests, int *array_of_statuses);

      void Buffer_attach(MPI_Offset bufsize);

      void Buffer_detach(void);

      void Inq_nreqs(int *nreqs);

      void Inq_buffer_usage(MPI_Offset *usage);

      void Inq_buffer_size(MPI_Offset *buf_size);

      void Inq_file_info(MPI_Info *info);

      void Inq_put_size(MPI_Offset *put_size);

      void Inq_get_size(MPI_Offset *get_size);

      void Inq_header_size(MPI_Offset *header_size);

      void Inq_header_extent(MPI_Offset *header_extent);

      void Inq_path(int *pathlen, char *path);

      void set_fill(FillMode fillmode, FillMode *old_modep=NULL);

   private:
	/* Do not allow definition of NcmpiFile involving copying any NcmpiFile
           or NcmpiGroup.  Because the destructor closes the file and releases
           al resources such an action could leave NcmpiFile objects in an
           invalid state
         */
	NcmpiFile& operator =(const NcmpiGroup & rhs);
	NcmpiFile& operator =(const NcmpiFile & rhs);
	NcmpiFile(const NcmpiGroup& rhs);
	NcmpiFile(const NcmpiFile& rhs);
   };

}




namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.
  class NcmpiVar;    // forward declaration.

  /*! Class represents a netCDF attribute local to a netCDF variable. */
  class NcmpiVarAtt : public NcmpiAtt
  {
  public:

    /*! assignment operator */
    NcmpiVarAtt& operator= (const NcmpiVarAtt& rhs);

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiVarAtt ();

    /*! The copy constructor. */
    NcmpiVarAtt(const NcmpiVarAtt& rhs) ;

    /*!
      Constructor for an existing local attribute.
      \param  grp        Parent Group object.
      \param  NcmpiVar      Parent NcmpiVar object.
      \param  index      The index (id) of the attribute.
    */
    NcmpiVarAtt(const NcmpiGroup& grp, const NcmpiVar& ncmpiVar, const int index);

    /*! Returns the NcmpiVar parent object. */
    NcmpiVar getParentVar() const;

    /*! comparator operator */
    friend bool operator<(const NcmpiVarAtt& lhs,const NcmpiVarAtt& rhs);

    /*! comparator operator  */
    friend bool operator>(const NcmpiVarAtt& lhs,const NcmpiVarAtt& rhs);

  };

}



namespace PnetCDF
{
  //  class NcmpiGroup;  // forward declaration.
  class NcmpiDim;    // forward declaration.
  //  class NcmpiVarAtt; // forward declaration.
  class NcmpiType;   // forward declaration.

  /*! Class represents a netCDF variable. */
  class NcmpiVar
  {
  public:

    /*! Used for chunking specifications (see NcmpiVar::setChunking,  NcmpiVar::getChunkingParameters). */
    enum ChunkMode
      {
	/*!
	  Chunked storage is used for this variable.
	*/
	ncmpi_CHUNKED    = NC_CHUNKED,
	/*! Contiguous storage is used for this variable. Variables with one or more unlimited
	  dimensions cannot use contiguous storage. If contiguous storage is turned on, the
	  chunkSizes parameter is ignored.
	*/
	ncmpi_CONTIGUOUS = NC_CONTIGUOUS
      };

    /*!
      Used to specifying the endianess of the data, (see NcmpiVar::setEndianness, NcmpiVar::getEndianness). By default this is NC_ENDIAN_NATIVE.
    */
    enum EndianMode
      {
	ncmpi_ENDIAN_NATIVE = NC_ENDIAN_NATIVE, //!< Native endian.
	ncmpi_ENDIAN_LITTLE = NC_ENDIAN_LITTLE, //!< Little endian.
	ncmpi_ENDIAN_BIG    = NC_ENDIAN_BIG     //!< Big endian.
      };

    /*! Used for checksum specification (see NcmpiVar::setChecksum, NcmpiVar::getChecksum). */
    enum ChecksumMode
      {
	ncmpi_NOCHECKSUM = NC_NOCHECKSUM, //!< No checksum (the default).
	ncmpi_FLETCHER32 = NC_FLETCHER32  //!< Selects the Fletcher32 checksum filter.
      };

    /*! destructor */
    ~NcmpiVar(){};

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiVar ();

    /*! Constructor for a variable .

      The variable must already exist in the netCDF file. New netCDF variables can be added using NcmpiGroup::addNcmpiVar();
      \param grp    Parent NcmpiGroup object.
      \param varId  Id of the is NcmpiVar object.
    */
    NcmpiVar (const NcmpiGroup& grp, const int& varId);

    /*! assignment operator  */
    NcmpiVar& operator =(const NcmpiVar& rhs);

    /*! equivalence operator */
    bool operator==(const NcmpiVar& rhs) const;

    /*!  != operator */
    bool operator!=(const NcmpiVar& rhs) const;

    /*! The copy constructor. */
    NcmpiVar(const NcmpiVar& ncmpiVar);

    /*! Name of this NcmpiVar object.*/
    std::string getName() const;

    /*! Gets parent group. */
    NcmpiGroup  getParentGroup() const;

    /*! Returns the variable type. */
    NcmpiType getType() const;


    /*! Rename the variable. */
    void rename( const std::string& newname ) const;


    /*! Get the variable id. */
    int  getId() const;

    /*! Returns true if this object variable is not defined. */
    bool isNull() const  {return nullObject;}

    /*! comparator operator  */
    friend bool operator<(const NcmpiVar& lhs,const NcmpiVar& rhs);

    /*! comparator operator  */
    friend bool operator>(const NcmpiVar& lhs,const NcmpiVar& rhs);

    /////////////////

    // Information about Dimensions

    /////////////////

    /*! The the number of dimensions. */
    int getDimCount() const ;

    /*! Gets the i'th NcmpiDim object. */
    NcmpiDim getDim(int i) const;

    /*! Gets the set of NcmpiDim objects. */
    std::vector<NcmpiDim> getDims() const;

    /////////////////

    // Information about Attributes

    /////////////////

    /*! Gets the number of attributes. */
    int getAttCount() const;

    /*! Gets attribute by name */
    NcmpiVarAtt getAtt(const std::string& name) const;

    /*! Gets the set of attributes. */
    std::map<std::string,NcmpiVarAtt> getAtts() const;




    /////////////////////////


    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const std::string& dataValues) const ;

    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned char* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const signed char* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, short datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, int datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, long datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, float datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, double datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, unsigned short datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, unsigned int datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, unsigned long long datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, long long datumValue) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const short* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const int* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const long* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const float* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const double* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned short* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned int* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const unsigned long long* dataValues) const ;
    /*! \overload
     */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const long long* dataValues) const ;
    /*!
      Creates a new variable attribute or if already exisiting replaces it.
      If you are writing a _Fill_Value_ attribute, and will tell the HDF5 layer to use
      the specified fill value for that variable.
      \par
      Although it's possible to create attributes of all types, text and double attributes are adequate for most purposes.
      \param name        Name of attribute.
      \param type        The attribute type.
      \param len         The length of the attribute (number of Nctype repeats).
      \param dataValues  Data Values to put into the new attribute.
      If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
      \return            The NcmpiVarAtt object for this new netCDF attribute.
    */
    NcmpiVarAtt putAtt(const std::string& name, const NcmpiType& type, MPI_Offset len, const void* dataValues) const ;



    ////////////////////

    // Chunking details

    ////////////////////

    /*! Sets chunking parameters.
      \param chunkMode   Enumeration type. Allowable parameters are: "ncmpi_CONTIGUOUS", "ncmpi_CHUNKED"
      \param chunksizes  Shape of chunking, used if ChunkMode=ncmpi_CHUNKED.
    */
    void setChunking(ChunkMode chunkMode, std::vector<MPI_Offset>& chunksizes) const;

    /*! Gets the chunking parameters
      \param chunkMode   On return contains either: "ncmpi_CONTIGUOUS" or "ncmpi_CHUNKED"
      \param chunksizes  On return contains shape of chunking, used if ChunkMode=ncmpi_CHUNKED.
    */
    void getChunkingParameters(ChunkMode& chunkMode, std::vector<MPI_Offset>& chunkSizes) const;



    ////////////////////

    // Fill details

    ////////////////////

    // Sets the fill parameters

    /*! Sets the fill parameters
      \param fillMode   Setting to true, turns on fill mode.
      \param fillValue  Fill value for the variable.
      Must be the same type as the variable. Ignored if fillMode=.false.
    */
    void setFill(bool fillMode,const void* fillValue=NULL) const;


    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      The function can be used for any type, including user-defined types.
      \param fillMode   On return set to true  if fill mode is enabled.
      \param fillValue  On return containts a pointer to fill value.
      Must be the same type as the variable. Ignored if fillMode=.false.
    */
    void getFillModeParameters(bool& fillMode, void* fillValue=NULL) const;


    /*! Gets the fill parameters
      \param On return set to true  if fill mode is enabled.
      \param On return  is set to the fill value.
    */
    template <class T> void getFillModeParameters(bool& fillMode,T& fillValue) const{
       int fillModeInt;
      ncmpiCheck(ncmpi_inq_var_fill(groupId,myId,&fillModeInt,&fillValue),__FILE__,__LINE__);
      fillMode= static_cast<bool> (fillModeInt == 0);
    }


    /* fill variable */
    void fillRec(MPI_Offset recno) const;

    ////////////////////

    // Compression details

    ////////////////////


    /*! Sets the compression parameters
      \param enableShuffleFilter Set to true to turn on shuffle filter.
      \param enableDeflateFilter Set to true to turn on deflate filter.
      \param deflateLevel        The deflate level, must be 0 and 9.
    */
    void setCompression(bool enableShuffleFilter, bool enableDeflateFilter, int deflateLevel) const;

    /*! Gets the compression parameters
      \param enableShuffleFilter  On return set to true if the shuffle filter is enabled.
      \param enableDeflateFilter  On return set to true if the deflate filter is enabled.
      \param deflateLevel         On return set to the deflate level.
    */
    void getCompressionParameters(bool& shuffleFilterEnabled, bool& deflateFilterEnabled, int& deflateLevel) const;



    ////////////////////

    // Endianness details

    ////////////////////


    /*! Sets the endianness of the variable.
      \param Endianness enumeration type. Allowable parameters are: "ncmpi_ENDIAN_NATIVE" (the default), "ncmpi_ENDIAN_LITTLE", "ncmpi_ENDIAN_BIG"
    */
    void setEndianness(EndianMode endianMode) const;

    /*! Gets the endianness of the variable.
      \return Endianness enumeration type. Allowable parameters are: "ncmpi_ENDIAN_NATIVE" (the default), "ncmpi_ENDIAN_LITTLE", "ncmpi_ENDIAN_BIG"
    */
    EndianMode getEndianness() const;



    ////////////////////

    // Checksum details

    ////////////////////


    /*! Sets the checksum parameters of a variable.
      \param ChecksumMode Enumeration type. Allowable parameters are: "ncmpi_NOCHECKSUM", "ncmpi_FLETCHER32".
    */
    void setChecksum(ChecksumMode checksumMode) const;

    /*! Gets the checksum parameters of the variable.
      \return ChecksumMode Enumeration type. Allowable parameters are: "ncmpi_NOCHECKSUM", "ncmpi_FLETCHER32".
    */
    ChecksumMode getChecksum() const;



    ////////////////////

    //  data  reading

    ////////////////////



    // Reads the entire data into the netCDF variable. (independent data mode)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar(void* dataValues) const;
    /*! \overload
     */
    void getVar(char* dataValues) const;
    /*! \overload
     */
    void getVar(unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar(signed char* dataValues) const;
    /*! \overload
     */
    void getVar(short* dataValues) const;
    /*! \overload
     */
    void getVar(int* dataValues) const;
    /*! \overload
     */
    void getVar(long* dataValues) const;
    /*! \overload
     */
    void getVar(float* dataValues) const;
    /*! \overload
     */
    void getVar(double* dataValues) const;
    /*! \overload
     */
    void getVar(unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar(unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar(unsigned long long* dataValues) const;
    /*!
      Reads the entire data from an netCDF variable.
      This is the simplest interface to use for reading the value of a scalar variable
      or when all the values of a multidimensional variable can be read at once. The values
      are read into consecutive locations with the last dimension varying fastest.

      Take care when using the simplest forms of this interface with record variables when you
      don't specify how many records are to be read. If you try to read all the values of a
      record variable into an array but there are more records in the file than you assume,
      more data will be read than you expect, which may cause a segmentation violation.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar(long long* dataValues) const;

    void getVar(void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;


    //////////////////////

    // Reads a single datum value from a variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar(const std::vector<MPI_Offset>& index, void* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, char* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, unsigned char* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, signed char* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, short* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, int* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, long* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, float* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, double* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, unsigned short* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, unsigned int* dataumValue) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& index, unsigned long long* dataumValue) const;
    /*! Reads a single datum value from a variable of an open netCDF dataset.
      The value is converted from the external data type of the variable, if necessary.

      \param index       Vector specifying the index of the data value to be read.
      The indices are relative to 0, so for example, the first data value of a two-dimensional
      variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable is a record variable, the first index is the record number.

      \param datumValue Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar(const std::vector<MPI_Offset>& index, long long* dataumValue) const;

    void getVar(const std::vector<MPI_Offset>& index, void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype) const;

    //////////////////////

    // Reads an array of values from a netCDF variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, void* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, signed char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, short* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, int* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, long* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, float* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, double* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned long long* dataValues) const;
    /*!
      Reads an array of values from a netCDF variable of an open netCDF dataset.
      The array is specified by giving a corner and a vector of edge lengths.
      The values are read into consecutive locations with the last dimension varying fastest.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, long long* dataValues) const;

    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    //////////////////////

    // Reads a subsampled (strided) array section of values from a netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, void* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, signed char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, short* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, int* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, long* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, float* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, double* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned long long* dataValues) const;
    /*!
      Reads a subsampled (strided) array section of values from a netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of edge lengths, and a stride vector.
      The values are read with the last dimension of the netCDF variable varying fastest.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param stride
      Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order,
      to the variable's dimensions. A value of 1 accesses adjacent values of the netCDF variable in the corresponding
      dimension; a value of 2 accesses every other value of the netCDF variable in the corresponding dimension; and so
      on. A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, long long* dataValues) const;

    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;


    //////////////////////

    // Reads a mapped array section of values from a netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, void* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, signed char* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, short* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, int* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, long* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, float* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, double* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned long long* dataValues) const;
    /*!
      Reads a mapped array section of values from a netCDF variable.
      The mapped array section is specified by giving a corner, a vector of edge lengths, a stride vector, and an
      index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the
      dimensions of a netCDF variable and the in-memory structure of the internal data array. No assumptions are
      made about the ordering or length of the dimensions of the data array.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param stride
      Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order,
      to the variable's dimensions. A value of 1 accesses adjacent values of the netCDF variable in the corresponding
      dimension; a value of 2 accesses every other value of the netCDF variable in the corresponding dimension; and so
      on. A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap
      Vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory
      structure of the internal data array. imap[0] gives the distance between elements of the internal array corresponding
      to the most slowly varying dimension of the netCDF variable. imap[n-1] (where n is the rank of the netCDF variable)
      gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the
      netCDF variable. Intervening imap elements correspond to other dimensions of the netCDF variable in the obvious way.
      Distances between elements are specified in type-independent units of elements (the distance between internal elements
      that occupy adjacent memory locations is 1 and not the element's byte-length as in netCDF 2).

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, long long* dataValues) const;

    void getVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    //////////////////////

    // Reads the entire data into the netCDF variable. (collective data mode)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar_all(void* dataValues) const;
    /*! \overload
     */
    void getVar_all(char* dataValues) const;
    /*! \overload
     */
    void getVar_all(unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar_all(signed char* dataValues) const;
    /*! \overload
     */
    void getVar_all(short* dataValues) const;
    /*! \overload
     */
    void getVar_all(int* dataValues) const;
    /*! \overload
     */
    void getVar_all(long* dataValues) const;
    /*! \overload
     */
    void getVar_all(float* dataValues) const;
    /*! \overload
     */
    void getVar_all(double* dataValues) const;
    /*! \overload
     */
    void getVar_all(unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar_all(unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar_all(unsigned long long* dataValues) const;
    /*!
      Reads the entire data from an netCDF variable.
      This is the simplest interface to use for reading the value of a scalar variable
      or when all the values of a multidimensional variable can be read at once. The values
      are read into consecutive locations with the last dimension varying fastest.

      Take care when using the simplest forms of this interface with record variables when you
      don't specify how many records are to be read. If you try to read all the values of a
      record variable into an array but there are more records in the file than you assume,
      more data will be read than you expect, which may cause a segmentation violation.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar_all(long long* dataValues) const;

    void getVar_all(void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////////

    // Reads a single datum value from a variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar_all(const std::vector<MPI_Offset>& index, void* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, char* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, unsigned char* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, signed char* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, short* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, int* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, long* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, float* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, double* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, unsigned short* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, unsigned int* dataumValue) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& index, unsigned long long* dataumValue) const;
    /*! Reads a single datum value from a variable of an open netCDF dataset.
      The value is converted from the external data type of the variable, if necessary.

      \param index       Vector specifying the index of the data value to be read.
      The indices are relative to 0, so for example, the first data value of a two-dimensional
      variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable is a record variable, the first index is the record number.

      \param datumValue Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar_all(const std::vector<MPI_Offset>& index, long long* dataumValue) const;

    void getVar_all(const std::vector<MPI_Offset>& index, void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype) const;

    //////////////////////

    // Reads an array of values from a netCDF variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, void* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, signed char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, short* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, int* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, long* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, float* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, double* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned long long* dataValues) const;
    /*!
      Reads an array of values from a netCDF variable of an open netCDF dataset.
      The array is specified by giving a corner and a vector of edge lengths.
      The values are read into consecutive locations with the last dimension varying fastest.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, long long* dataValues) const;

    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    //////////////////////

    // Reads a subsampled (strided) array section of values from a netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, void* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, signed char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, short* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, int* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, long* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, float* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, double* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned long long* dataValues) const;
    /*!
      Reads a subsampled (strided) array section of values from a netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of edge lengths, and a stride vector.
      The values are read with the last dimension of the netCDF variable varying fastest.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param stride
      Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order,
      to the variable's dimensions. A value of 1 accesses adjacent values of the netCDF variable in the corresponding
      dimension; a value of 2 accesses every other value of the netCDF variable in the corresponding dimension; and so
      on. A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, long long* dataValues) const;

    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;


    //////////////////////

    // Reads a mapped array section of values from a netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, void* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, signed char* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, short* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, int* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, long* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, float* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, double* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned short* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned int* dataValues) const;
    /*! \overload
     */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned long long* dataValues) const;
    /*!
      Reads a mapped array section of values from a netCDF variable.
      The mapped array section is specified by giving a corner, a vector of edge lengths, a stride vector, and an
      index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the
      dimensions of a netCDF variable and the in-memory structure of the internal data array. No assumptions are
      made about the ordering or length of the dimensions of the data array.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param stride
      Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order,
      to the variable's dimensions. A value of 1 accesses adjacent values of the netCDF variable in the corresponding
      dimension; a value of 2 accesses every other value of the netCDF variable in the corresponding dimension; and so
      on. A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap
      Vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory
      structure of the internal data array. imap[0] gives the distance between elements of the internal array corresponding
      to the most slowly varying dimension of the netCDF variable. imap[n-1] (where n is the rank of the netCDF variable)
      gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the
      netCDF variable. Intervening imap elements correspond to other dimensions of the netCDF variable in the obvious way.
      Distances between elements are specified in type-independent units of elements (the distance between internal elements
      that occupy adjacent memory locations is 1 and not the element's byte-length as in netCDF 2).

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, long long* dataValues) const;

    void getVar_all(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;



    ////////////////////

    //  Nonblocking data reading

    ////////////////////

    // Reads the entire data into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void igetVar(void* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(unsigned char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(signed char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(long* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(float* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(double* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(unsigned short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(unsigned int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(unsigned long long* dataValues, int *req) const;
    /*!
      Reads the entire data from an netCDF variable.
      This is the simplest interface to use for reading the value of a scalar variable
      or when all the values of a multidimensional variable can be read at once. The values
      are read into consecutive locations with the last dimension varying fastest.

      Take care when using the simplest forms of this interface with record variables when you
      don't specify how many records are to be read. If you try to read all the values of a
      record variable into an array but there are more records in the file than you assume,
      more data will be read than you expect, which may cause a segmentation violation.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void igetVar(long long* dataValues, int *req) const;

    void igetVar(void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;


    //////////////////////

    // Reads a single datum value from a variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void igetVar(const std::vector<MPI_Offset>& index, void* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, char* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, unsigned char* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, signed char* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, short* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, int* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, long* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, float* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, double* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, unsigned short* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, unsigned int* dataumValue, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& index, unsigned long long* dataumValue, int *req) const;
    /*! Reads a single datum value from a variable of an open netCDF dataset.
      The value is converted from the external data type of the variable, if necessary.

      \param index       Vector specifying the index of the data value to be read.
      The indices are relative to 0, so for example, the first data value of a two-dimensional
      variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable is a record variable, the first index is the record number.

      \param datumValue Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void igetVar(const std::vector<MPI_Offset>& index, long long* dataumValue, int *req) const;

    void igetVar(const std::vector<MPI_Offset>& index, void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    //////////////////////

    // Reads an array of values from a netCDF variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, void* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, signed char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, long* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, float* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, double* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, unsigned long long* dataValues, int *req) const;
    /*!
      Reads an array of values from a netCDF variable of an open netCDF dataset.
      The array is specified by giving a corner and a vector of edge lengths.
      The values are read into consecutive locations with the last dimension varying fastest.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, long long* dataValues, int *req) const;

    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    //////////////////////

    // Reads a subsampled (strided) array section of values from a netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, void* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, signed char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, long* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, float* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, double* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, unsigned long long* dataValues, int *req) const;
    /*!
      Reads a subsampled (strided) array section of values from a netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of edge lengths, and a stride vector.
      The values are read with the last dimension of the netCDF variable varying fastest.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param stride
      Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order,
      to the variable's dimensions. A value of 1 accesses adjacent values of the netCDF variable in the corresponding
      dimension; a value of 2 accesses every other value of the netCDF variable in the corresponding dimension; and so
      on. A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, long long* dataValues, int *req) const;

    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;


    //////////////////////

    // Reads a mapped array section of values from a netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, void* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, signed char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, long* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, float* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, double* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, unsigned long long* dataValues, int *req) const;
    /*!
      Reads a mapped array section of values from a netCDF variable.
      The mapped array section is specified by giving a corner, a vector of edge lengths, a stride vector, and an
      index mapping vector. The index mapping vector is a vector of integers that specifies the mapping between the
      dimensions of a netCDF variable and the in-memory structure of the internal data array. No assumptions are
      made about the ordering or length of the dimensions of the data array.

      \param start
      Vector specifying the index in the variable where the first of the data values will be read.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of start must be the same as the number of dimensions of the specified variable.
      The elements of start correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first index would correspond to the starting record number for reading the data values.

      \param count
      Vector specifying the edge lengths along each dimension of the block of data values to be read.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of count is the number of
      dimensions of the specified variable. The elements of count correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param stride
      Vector specifying the interval between selected indices. The elements of the stride vector correspond, in order,
      to the variable's dimensions. A value of 1 accesses adjacent values of the netCDF variable in the corresponding
      dimension; a value of 2 accesses every other value of the netCDF variable in the corresponding dimension; and so
      on. A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap
      Vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory
      structure of the internal data array. imap[0] gives the distance between elements of the internal array corresponding
      to the most slowly varying dimension of the netCDF variable. imap[n-1] (where n is the rank of the netCDF variable)
      gives the distance between elements of the internal array corresponding to the most rapidly varying dimension of the
      netCDF variable. Intervening imap elements correspond to other dimensions of the netCDF variable in the obvious way.
      Distances between elements are specified in type-independent units of elements (the distance between internal elements
      that occupy adjacent memory locations is 1 and not the element's byte-length as in netCDF 2).

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, long long* dataValues, int *req) const;

    void igetVar(const std::vector<MPI_Offset>& start, const std::vector<MPI_Offset>& count,  const std::vector<MPI_Offset>& stride, const std::vector<MPI_Offset>& imap, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    //////////////////////

    // Reads a list of subarrays of values from a netCDF variable of an open netCDF dataset. (independent I/O APIs)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], char* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], signed char* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], short* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], int* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], float* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], double* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int* dataValues) const;
    /*! \overload
     */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long* dataValues) const;
    /*!
      Reads a list of subarrays from a netCDF variable of an open netCDF dataset.
      Each subarray i is specified by giving a corner (starts[i][*]) and a vector of edge lengths (counts[i][*]).
      The values are read into consecutive locations with the last dimension varying fastest.

      \param num
      Number of subarrays.

      \param starts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      Each subarray i is specified by starts[i][*], the first of the data values will be read, and counts[i][*], edge lengths of the subarray.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of the second dimension of starts and counts must be the same as the number of dimensions of the specified variable.
      The elements of starts's second dimension correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first element starts[*][0] would correspond to the starting record number for reading the data values.

      \param counts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of each count[i] is the number of
      dimensions of the specified variable. The elements of each count[i] correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count[i] corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long long* dataValues) const;

    void getVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    // Reads a list of subarrays of values from a netCDF variable of an open netCDF dataset. (collective I/O APIs)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], char* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], signed char* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], short* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], int* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], float* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], double* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int* dataValues) const;
    /*! \overload
     */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long* dataValues) const;
    /*!
      Reads a list of subarrays from a netCDF variable of an open netCDF dataset.
      Each subarray i is specified by giving a corner (starts[i][*]) and a vector of edge lengths (counts[i][*]).
      The values are read into consecutive locations with the last dimension varying fastest.

      \param num
      Number of subarrays.

      \param starts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      Each subarray i is specified by starts[i][*], the first of the data values will be read, and counts[i][*], edge lengths of the subarray.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of the second dimension of starts and counts must be the same as the number of dimensions of the specified variable.
      The elements of starts's second dimension correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first element starts[*][0] would correspond to the starting record number for reading the data values.

      \param counts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of each count[i] is the number of
      dimensions of the specified variable. The elements of each count[i] correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count[i] corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long long* dataValues) const;

    void getVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    /* vard APIs take filetype and buftype */
    void getVard    (MPI_Datatype filetype, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;
    void getVard_all(MPI_Datatype filetype, void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    //////////////////////

    // Nonblocking reads a list of subarrays of values from a netCDF variable of an open netCDF dataset.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], signed char* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], float* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], double* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int* dataValues, int *req) const;
    /*! \overload
     */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long* dataValues, int *req) const;
    /*!
      Reads a list of subarrays from a netCDF variable of an open netCDF dataset.
      Each subarray i is specified by giving a corner (starts[i][*]) and a vector of edge lengths (counts[i][*]).
      The values are read into consecutive locations with the last dimension varying fastest.

      \param num
      Number of subarrays.

      \param starts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      Each subarray i is specified by starts[i][*], the first of the data values will be read, and counts[i][*], edge lengths of the subarray.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of the second dimension of starts and counts must be the same as the number of dimensions of the specified variable.
      The elements of starts's second dimension correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first element starts[*][0] would correspond to the starting record number for reading the data values.

      \param counts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      To read a single value, for example, specify count as (1, 1, ... , 1). The length of each count[i] is the number of
      dimensions of the specified variable. The elements of each count[i] correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count[i] corresponds to a count of the number of records to read.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is read. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long long* dataValues, int *req) const;

    void igetVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    //////////////////////


    //  data writing (independent data mode)

    ////////////////////

    // Writes the entire data into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar(const void* dataValues) const;
    /*! \overload
     */
    void putVar(const char* dataValues) const;
    /*!  \overload
    */
    void putVar(const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar(const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar(const short* dataValues) const;
    /*!  \overload
    */
    void putVar(const int* dataValues) const;
    /*!  \overload
    */
    void putVar(const long* dataValues) const;
    /*!  \overload
    */
    void putVar(const float* dataValues) const;
    /*!  \overload
    */
    void putVar(const double* dataValues) const;
    /*!  \overload
    */
    void putVar(const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar(const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar(const unsigned long long* dataValues) const;
    /*!
      Writes the entire data into the netCDF variable.
      This is the simplest interface to use for writing a value in a scalar variable
      or whenever all the values of a multidimensional variable can all be
      written at once. The values to be written are associated with the
      netCDF variable by assuming that the last dimension of the netCDF
      variable varies fastest in the C interface.

      Take care when using the simplest forms of this interface with
      record variables when you don't specify how many records are to be
      written. If you try to write all the values of a record variable
      into a netCDF file that has no record data yet (hence has 0 records),
      nothing will be written. Similarly, if you try to write all of a record
      variable but there are more records in the file than you assume, more data
      may be written to the file than you supply, which may result in a
      segmentation violation.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVar(const long long* dataValues) const;

    void putVar(const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    /////////////////////////

    // Writes a single datum into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar(const std::vector<MPI_Offset>& index, const void* dataumValue) const;
    /*! \overload
     */
    void putVar(const std::vector<MPI_Offset>& index, const std::string& dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const unsigned char* dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const signed char* dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const short dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const int dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const long dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const float dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const double dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const unsigned short dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const unsigned int dataumValue) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& index, const unsigned long long dataumValue) const;
    /*!
      Writes a single datum into the netCDF variable.

      \param index      Vector specifying the index where the data values will be written. The indices are relative to 0, so for example,
      the first data value of a two-dimensional variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable uses the unlimited dimension, the first index would correspond to the unlimited dimension.

      \param datumValue The data value. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVar(const std::vector<MPI_Offset>& index, const long long dataumValue) const;

    void putVar(const std::vector<MPI_Offset>& index, const void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype) const;

    /////////////////////////

    // Writes an array of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues) const;
    /*! \overload
     */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const short* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const int* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const float* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const double* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned long long* dataValues) const;
    /*!
      Writes an array of values into the netCDF variable.
      The portion of the netCDF variable to write is specified by giving a corner and a vector of edge lengths
      that refer to an array section of the netCDF variable. The values to be written are associated with
      the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable
      type, type conversion will occur. (However, no type conversion is
      carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long long* dataValues) const;
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////

    // Writes a set of subsampled array values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues) const;
    /*! \overload
     */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const short* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const int* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const float* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const double* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned long long* dataValues) const;
    /*!
      Writes an array of values into the netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of counts, and a stride vector.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is  carried out for variables using the user-defined data types: ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long long* dataValues) const;

    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////

    // Writes a mapped array section of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues) const;
    /*! \overload
     */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const short* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const int* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const float* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const double* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned long long* dataValues) const;
    /*!
      Writes a mapped array section of values into the netCDF variable.
      The mapped array section is specified by giving a corner, a vector of counts, a stride vector, and an index mapping vector.
      The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      No assumptions are made about the ordering or length of the dimensions of the data array.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap Vector  specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      The elements of the index mapping vector correspond, in order, to the netCDF variable's dimensions (imap[0] gives the distance between elements
      of the internal array corresponding to the most slowly varying dimension of the netCDF variable). Distances between elements are
      specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is
      1 and not the element's byte-length as in netCDF 2). A NULL argument means the memory-resident values have the same structure as
      the associated netCDF variable.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
     (However, no type conversion is carried out for variables using the user-defined data types:  ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
*/
    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long long* dataValues) const;

    void putVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////////

    //  data writing (collective data mode)

    ////////////////////

    // Writes the entire data into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar_all(const void* dataValues) const;
    /*! \overload
     */
    void putVar_all(const char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const long* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const float* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const double* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const unsigned long long* dataValues) const;
    /*!
      Writes the entire data into the netCDF variable.
      This is the simplest interface to use for writing a value in a scalar variable
      or whenever all the values of a multidimensional variable can all be
      written at once. The values to be written are associated with the
      netCDF variable by assuming that the last dimension of the netCDF
      variable varies fastest in the C interface.

      Take care when using the simplest forms of this interface with
      record variables when you don't specify how many records are to be
      written. If you try to write all the values of a record variable
      into a netCDF file that has no record data yet (hence has 0 records),
      nothing will be written. Similarly, if you try to write all of a record
      variable but there are more records in the file than you assume, more data
      may be written to the file than you supply, which may result in a
      segmentation violation.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVar_all(const long long* dataValues) const;

    void putVar_all(const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    /////////////////////////

    // Writes a single datum into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar_all(const std::vector<MPI_Offset>& index, const void* dataumValue) const;
    /*! \overload
     */
    void putVar_all(const std::vector<MPI_Offset>& index, const std::string& dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const unsigned char* dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const signed char* dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const short dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const int dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const long dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const float dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const double dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const unsigned short dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const unsigned int dataumValue) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const unsigned long long dataumValue) const;
    /*!
      Writes a single datum into the netCDF variable.

      \param index      Vector specifying the index where the data values will be written. The indices are relative to 0, so for example,
      the first data value of a two-dimensional variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable uses the unlimited dimension, the first index would correspond to the unlimited dimension.

      \param datumValue The data value. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVar_all(const std::vector<MPI_Offset>& index, const long long dataumValue) const;

    void putVar_all(const std::vector<MPI_Offset>& index, const void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype) const;

    /////////////////////////

    // Writes an array of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues) const;
    /*! \overload
     */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const float* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const double* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned long long* dataValues) const;
    /*!
      Writes an array of values into the netCDF variable.
      The portion of the netCDF variable to write is specified by giving a corner and a vector of edge lengths
      that refer to an array section of the netCDF variable. The values to be written are associated with
      the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable
      type, type conversion will occur. (However, no type conversion is
      carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long long* dataValues) const;
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////

    // Writes a set of subsampled array values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues) const;
    /*! \overload
     */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const float* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const double* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned long long* dataValues) const;
    /*!
      Writes an array of values into the netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of counts, and a stride vector.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is  carried out for variables using the user-defined data types: ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long long* dataValues) const;

    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////

    // Writes a mapped array section of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues) const;
    /*! \overload
     */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const signed char* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const float* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const double* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned long long* dataValues) const;
    /*!
      Writes a mapped array section of values into the netCDF variable.
      The mapped array section is specified by giving a corner, a vector of counts, a stride vector, and an index mapping vector.
      The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      No assumptions are made about the ordering or length of the dimensions of the data array.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap Vector  specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      The elements of the index mapping vector correspond, in order, to the netCDF variable's dimensions (imap[0] gives the distance between elements
      of the internal array corresponding to the most slowly varying dimension of the netCDF variable). Distances between elements are
      specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is
      1 and not the element's byte-length as in netCDF 2). A NULL argument means the memory-resident values have the same structure as
      the associated netCDF variable.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
     (However, no type conversion is carried out for variables using the user-defined data types:  ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
*/
    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long long* dataValues) const;

    void putVar_all(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////////

    // Writes a list of subarrays into the netCDF variable. (independent I/O APIs)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void* dataValues) const;
    /*! \overload
     */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long* dataValues) const;
    /*!
      Writes a list of subarrays into the netCDF variable.
      Each subarray i is specified by giving a corner (starts[i][*]) and a vector of edge lengths (counts[i][*]).
      The values to be written are associated with the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param num
      Number of subarrays.

      \param starts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      Each subarray i is specified by starts[i][*], the first of the data values will be written, and counts[i][*], edge lengths of the subarray.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of the second dimension of starts and counts must be the same as the number of dimensions of the specified variable.
      The elements of starts's second dimension correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first element starts[*][0] would correspond to the starting record number for writing the data values.

      \param counts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      To write a single value, for example, specify count as (1, 1, ... , 1). The length of each count[i] is the number of
      dimensions of the specified variable. The elements of each count[i] correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count[i] corresponds to a count of the number of records to write.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is written. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
    */
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long* dataValues) const;
    void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////

    // Writes an array of values into the netCDF variable. (collective I/O APIs)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void* dataValues) const;
    /*! \overload
     */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int* dataValues) const;
    /*!  \overload
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long* dataValues) const;
    /*!
      Writes an array of values into the netCDF variable.
      The portion of the netCDF variable to write is specified by giving a corner and a vector of edge lengths
      that refer to an array section of the netCDF variable. The values to be written are associated with
      the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable
      type, type conversion will occur. (However, no type conversion is
      carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long* dataValues) const;
    void putVarn_all(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    /* vard APIs take filetype and buftype */
    void putVard    (MPI_Datatype filetype, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;
    void putVard_all(MPI_Datatype filetype, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype) const;

    ////////////////

    //  Nonblocking data writing

    ////////////////////


    // Writes the entire data into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void iputVar(const void* dataValues, int *req) const;
    /*! \overload
     */
    void iputVar(const char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const long* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const float* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const double* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const unsigned long long* dataValues, int *req) const;
    /*!
      Writes the entire data into the netCDF variable.
      This is the simplest interface to use for writing a value in a scalar variable
      or whenever all the values of a multidimensional variable can all be
      written at once. The values to be written are associated with the
      netCDF variable by assuming that the last dimension of the netCDF
      variable varies fastest in the C interface.

      Take care when using the simplest forms of this interface with
      record variables when you don't specify how many records are to be
      written. If you try to write all the values of a record variable
      into a netCDF file that has no record data yet (hence has 0 records),
      nothing will be written. Similarly, if you try to write all of a record
      variable but there are more records in the file than you assume, more data
      may be written to the file than you supply, which may result in a
      segmentation violation.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void iputVar(const long long* dataValues, int *req) const;

    void iputVar(const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    /////////////////////////

    // Writes a single datum into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void iputVar(const std::vector<MPI_Offset>& index, const void* dataumValue, int *req) const;
    /*! \overload
     */
    void iputVar(const std::vector<MPI_Offset>& index, const std::string& dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const unsigned char* dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const signed char* dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const short dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const int dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const long dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const float dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const double dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const unsigned short dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const unsigned int dataumValue, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& index, const unsigned long long dataumValue, int *req) const;
    /*!
      Writes a single datum into the netCDF variable.

      \param index      Vector specifying the index where the data values will be written. The indices are relative to 0, so for example,
      the first data value of a two-dimensional variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable uses the unlimited dimension, the first index would correspond to the unlimited dimension.

      \param datumValue The data value. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void iputVar(const std::vector<MPI_Offset>& index, const long long dataumValue, int *req) const;

    void iputVar(const std::vector<MPI_Offset>& index, const void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    /////////////////////////

    // Writes an array of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues, int *req) const;
    /*! \overload
     */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const float* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const double* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned long long* dataValues, int *req) const;
    /*!
      Writes an array of values into the netCDF variable.
      The portion of the netCDF variable to write is specified by giving a corner and a vector of edge lengths
      that refer to an array section of the netCDF variable. The values to be written are associated with
      the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable
      type, type conversion will occur. (However, no type conversion is
      carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long long* dataValues, int *req) const;
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    ////////////////

    // Writes a set of subsampled array values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues, int *req) const;
    /*! \overload
     */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const float* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const double* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned long long* dataValues, int *req) const;
    /*!
      Writes an array of values into the netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of counts, and a stride vector.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is  carried out for variables using the user-defined data types: ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long long* dataValues, int *req) const;

    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    ////////////////

    // Writes a mapped array section of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues, int *req) const;
    /*! \overload
     */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const float* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const double* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned long long* dataValues, int *req) const;
    /*!
      Writes a mapped array section of values into the netCDF variable.
      The mapped array section is specified by giving a corner, a vector of counts, a stride vector, and an index mapping vector.
      The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      No assumptions are made about the ordering or length of the dimensions of the data array.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap Vector  specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      The elements of the index mapping vector correspond, in order, to the netCDF variable's dimensions (imap[0] gives the distance between elements
      of the internal array corresponding to the most slowly varying dimension of the netCDF variable). Distances between elements are
      specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is
      1 and not the element's byte-length as in netCDF 2). A NULL argument means the memory-resident values have the same structure as
      the associated netCDF variable.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
     (However, no type conversion is carried out for variables using the user-defined data types:  ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
*/
    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long long* dataValues, int *req) const;

    void iputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    ////////////////////

    // Writes a list of subarrays into the netCDF variable. (independent I/O APIs)
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void putVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void* dataValues) const;
    /*! \overload
     */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long* dataValues, int *req) const;
    /*!
      Writes a list of subarrays into the netCDF variable.
      Each subarray i is specified by giving a corner (starts[i][*]) and a vector of edge lengths (counts[i][*]).
      The values to be written are associated with the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param num
      Number of subarrays.

      \param starts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      Each subarray i is specified by starts[i][*], the first of the data values will be written, and counts[i][*], edge lengths of the subarray.
      The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
      The length of the second dimension of starts and counts must be the same as the number of dimensions of the specified variable.
      The elements of starts's second dimension correspond, in order, to the variable's dimensions. Hence, if the variable is a record variable,
      the first element starts[*][0] would correspond to the starting record number for writing the data values.

      \param counts
      2D array of size [num][ndims] where num is the number of subarrays to get and ndims if the number of dimensions of the specified variable.
      To write a single value, for example, specify count as (1, 1, ... , 1). The length of each count[i] is the number of
      dimensions of the specified variable. The elements of each count[i] correspond, in order, to the variable's dimensions.
      Hence, if the variable is a record variable, the first element of count[i] corresponds to a count of the number of records to write.
      Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues Pointer to the location into which the data value is written. If the type of
      data value differs from the netCDF variable type, type conversion will occur.
    */
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long* dataValues, int *req) const;
    void iputVarn(const int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    ////////////////////

    //  Buffered nonblocking data writing

    ////////////////////

    // Writes the entire data into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void bputVar(const void* dataValues, int *req) const;
    /*! \overload
     */
    void bputVar(const char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const long* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const float* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const double* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const unsigned long long* dataValues, int *req) const;
    /*!
      Writes the entire data into the netCDF variable.
      This is the simplest interface to use for writing a value in a scalar variable
      or whenever all the values of a multidimensional variable can all be
      written at once. The values to be written are associated with the
      netCDF variable by assuming that the last dimension of the netCDF
      variable varies fastest in the C interface.

      Take care when using the simplest forms of this interface with
      record variables when you don't specify how many records are to be
      written. If you try to write all the values of a record variable
      into a netCDF file that has no record data yet (hence has 0 records),
      nothing will be written. Similarly, if you try to write all of a record
      variable but there are more records in the file than you assume, more data
      may be written to the file than you supply, which may result in a
      segmentation violation.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void bputVar(const long long* dataValues, int *req) const;

    void bputVar(const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    /////////////////////////

    // Writes a single datum into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void bputVar(const std::vector<MPI_Offset>& index, const void* dataumValue, int *req) const;
    /*! \overload
     */
    void bputVar(const std::vector<MPI_Offset>& index, const std::string& dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const unsigned char* dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const signed char* dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const short dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const int dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const long dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const float dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const double dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const unsigned short dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const unsigned int dataumValue, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& index, const unsigned long long dataumValue, int *req) const;
    /*!
      Writes a single datum into the netCDF variable.

      \param index      Vector specifying the index where the data values will be written. The indices are relative to 0, so for example,
      the first data value of a two-dimensional variable would have index (0,0). The elements of index must correspond to the variable's dimensions.
      Hence, if the variable uses the unlimited dimension, the first index would correspond to the unlimited dimension.

      \param datumValue The data value. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void bputVar(const std::vector<MPI_Offset>& index, const long long dataumValue, int *req) const;

    void bputVar(const std::vector<MPI_Offset>& index, const void* dataumValue, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    /////////////////////////

    // Writes an array of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues, int *req) const;
    /*! \overload
     */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const float* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const double* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const unsigned long long* dataValues, int *req) const;
    /*!
      Writes an array of values into the netCDF variable.
      The portion of the netCDF variable to write is specified by giving a corner and a vector of edge lengths
      that refer to an array section of the netCDF variable. The values to be written are associated with
      the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable
      type, type conversion will occur. (However, no type conversion is
      carried out for variables using the user-defined data types:
      ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const long long* dataValues, int *req) const;
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    ////////////////

    // Writes a set of subsampled array values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues, int *req) const;
    /*! \overload
     */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const float* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const double* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const unsigned long long* dataValues, int *req) const;
    /*!
      Writes an array of values into the netCDF variable.
      The subsampled array section is specified by giving a corner, a vector of counts, and a stride vector.

      \param startp  Vector specifying the index where the first data values will be written.  The indices are relative to 0, so for
      example, the first data value of a variable would have index (0, 0, ... , 0). The elements of start correspond, in order, to the
      variable's dimensions. Hence, if the variable is a record variable, the first index corresponds to the starting record number for writing the data values.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
      (However, no type conversion is  carried out for variables using the user-defined data types: ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const long long* dataValues, int *req) const;

    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    ////////////////

    // Writes a mapped array section of values into the netCDF variable.
    /*!
      This is an overloaded member function, provided for convenience.
      It differs from the above function in what argument(s) it accepts.
      In addition, no data conversion is carried out. This means that
      the type of the data in memory must match the type of the variable.
    */
    // void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues, int *req) const;
    /*! \overload
     */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const signed char* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const float* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const double* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned short* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned int* dataValues, int *req) const;
    /*!  \overload
    */
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const unsigned long long* dataValues, int *req) const;
    /*!
      Writes a mapped array section of values into the netCDF variable.
      The mapped array section is specified by giving a corner, a vector of counts, a stride vector, and an index mapping vector.
      The index mapping vector is a vector of integers that specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      No assumptions are made about the ordering or length of the dimensions of the data array.

      \param countp  Vector specifying the number of indices selected along each dimension.
      To write a single value, for example, specify count as (1, 1, ... , 1). The elements of
      count correspond, in order, to the variable's dimensions. Hence, if the variable is a record
      variable, the first element of count corresponds to a count of the number of records to write. Note: setting any element
      of the count array to zero causes the function to exit without error, and without doing anything.

      \param stridep  A vector of MPI_Offset integers that specifies the sampling interval along each dimension of the netCDF variable.
      The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0] gives the sampling interval
      along the most slowly varying dimension of the netCDF variable). Sampling intervals are specified in type-independent units of
      elements (a value of 1 selects consecutive elements of the netCDF variable along the corresponding dimension, a value of 2 selects
      every other element, etc.). A NULL stride argument is treated as (1, 1, ... , 1).

      \param imap Vector  specifies the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.
      The elements of the index mapping vector correspond, in order, to the netCDF variable's dimensions (imap[0] gives the distance between elements
      of the internal array corresponding to the most slowly varying dimension of the netCDF variable). Distances between elements are
      specified in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is
      1 and not the element's byte-length as in netCDF 2). A NULL argument means the memory-resident values have the same structure as
      the associated netCDF variable.

      \param dataValues The data values. The order in which the data will be written to the netCDF variable is with the last
      dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
     (However, no type conversion is carried out for variables using the user-defined data types:  ncmpi_Vlen, ncmpi_Opaque, ncmpi_Compound and ncmpi_Enum.)
*/
    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const long long* dataValues, int *req) const;

    void bputVar(const std::vector<MPI_Offset>& startp, const std::vector<MPI_Offset>& countp, const std::vector<MPI_Offset>& stridep, const std::vector<MPI_Offset>& imapp, const void* dataValues, MPI_Offset bufcount, MPI_Datatype buftype, int *req) const;

    void Inq_file_offset(MPI_Offset *offset);

  private:

    bool nullObject;

    int myId;

    int groupId;

  };


}







namespace PnetCDF
{
  class NcmpiGroup;  // forward declaration.

  /*! Class represents a netCDF VLEN type */
  class NcmpiVlenType : public NcmpiType
  {
  public:

    /*! Constructor generates a \ref isNull "null object". */
    NcmpiVlenType();

    /*!
      Constructor.
      The vlen Type must already exist in the netCDF file. New netCDF vlen types can be added
      using NcmpiGroup::addNcmpiVlenType();
      \param grp        The parent group where this type is defined.
      \param name       Name of new type.
    */
    NcmpiVlenType(const NcmpiGroup& grp, const std::string& name);

    /*!
      Constructor.
      Constructs from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of a Vlen type.
      \param ncmpiType     A Nctype object.
    */
    NcmpiVlenType(const NcmpiType& ncmpiType);

    /*! assignment operator */
    NcmpiVlenType& operator=(const NcmpiVlenType& rhs);

    /*!
      Assignment operator.
      This assigns from the base type NcmpiType object. Will throw an exception if the NcmpiType is not the base of a Vlen type.
    */
    NcmpiVlenType& operator=(const NcmpiType& rhs);

    /*! The copy constructor. */
    NcmpiVlenType(const NcmpiVlenType& rhs);

    ~NcmpiVlenType(){;}

    /*! Returns the base type. */
    NcmpiType  getBaseType() const;

  };

}

